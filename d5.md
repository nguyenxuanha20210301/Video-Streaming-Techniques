## D.5. Hiện tượng stall (rebuffering)

Trong bối cảnh HTTP adaptive streaming (DASH/HLS), **stall** (hay **rebuffering**) là khoảng thời gian mà video **tạm dừng phát** vì buffer phát ($B(t)$) đã cạn. Đây là một trong những yếu tố **tiêu cực nhất** đối với QoE: nhiều nghiên cứu cho thấy người dùng **ghét stall hơn rất nhiều** so với việc xem ở chất lượng thấp hơn nhưng mượt \[D37–D39].

Trong mục này, ta:

- Mô hình hóa **thời gian stall** theo diễn tiến buffer và profile throughput mạng.  
- Phân tích **tác động định lượng** của stall lên QoE, liên hệ với các mô hình như ITU-T P.1203, các nghiên cứu thực nghiệm của Hulu/Netflix/YouTube.

---

### D.5.1. Mô hình hóa thời gian stall

Ta sử dụng lại các biến đã định nghĩa ở mục D.2:

- $k$: chỉ số segment / decision ($k = 1,2,\dots,K$).  
- $T_{\text{seg}}$: độ dài mỗi segment (s).  
- $R_k$: bitrate video (bit/s) đã chọn tại segment thứ $k$.  
- $S_k$: kích thước segment $k$ (bit), với $S_k \approx R_k T_{\text{seg}}$.  
- $C_k$: throughput mạng thực trong khi tải segment $k$ (bit/s).  
- $D_k$: thời gian tải segment $k$ (s), $D_k = \frac{S_k}{C_k} \approx \frac{R_k T_{\text{seg}}}{C_k}$.  
- $B_k$: mức buffer (giây video) **ngay trước** khi bắt đầu tải segment $k$.  
- $T_{\text{stall},k}$: thời gian stall phát sinh trong khi tải segment $k$ (s).  
- $T_{\text{stall,total}}$: tổng thời gian stall trong cả phiên (s).

#### D.5.1.1. Quan hệ buffer–stall cho từng segment

Nhắc lại mô hình diễn tiến buffer rời rạc (D.2):

$$
B_{k+1} = \max\{0,\ B_k - D_k\} + T_{\text{seg}},
$$

và thời gian stall tại segment $k$:

$$
T_{\text{stall},k} = \max\{0,\ D_k - B_k\}.
$$

Diễn giải:

- Nếu $B_k > D_k$:
  - buffer đủ để “che” toàn bộ thời gian tải;  
  - không stall ($T_{\text{stall},k}=0$),  
  - buffer mới: $B_{k+1} = B_k - D_k + T_{\text{seg}}$.

- Nếu $B_k \le D_k$:
  - buffer sẽ cạn sau $B_k$ giây;  
  - playback dừng (stall) trong phần còn lại $D_k - B_k$ giây;  
  - sau khi tải xong, buffer bằng đúng $T_{\text{seg}}$ giây video mới:

    $$
    B_{k+1} = T_{\text{seg}},
    \quad
    T_{\text{stall},k} = D_k - B_k.
    $$

Tổng stall:

$$
T_{\text{stall,total}} = \sum_{k=1}^{K} T_{\text{stall},k} = \sum_{k=1}^K \max\{0,\ D_k - B_k\}.
$$

Để tiện phân tích, ta viết $D_k$ theo $R_k$ và $C_k$:

$$
T_{\text{stall},k} = \max\left\{ 0,\ \frac{R_k T_{\text{seg}}}{C_k} - B_k \right\}.
$$

Như vậy stall tăng khi:

- bitrate $R_k$ quá cao so với $C_k$,  
- buffer $B_k$ nhỏ (do vừa startup hoặc vừa trải qua một giai đoạn throughput thấp).

#### D.5.1.2. Mô hình thời gian stall theo trace băng thông

Để nhìn rõ hơn, ta xét **trace băng thông** liên tục $C(t)$ và buffer $B(t)$ trong mô hình fluid (D.2), với:

- $B(t)$: buffer tính theo giây video;  
- $R(t)$: bitrate phát (giả sử piecewise-constant, tương đương $R_k$ cho từng segment);  
- $C(t)$: throughput nhận được.

Phương trình buffer khi **không stall**:

$$
\frac{dB(t)}{dt} = \frac{C(t)}{R(t)} - 1,
\quad \text{khi } B(t) > 0.
$$

Khi $B(t)$ chạm 0:

- playback dừng, không còn tiêu thụ video;  
- buffer chỉ tăng nhờ tải, với:

  $$
  \frac{dB(t)}{dt} =
  \frac{C(t)}{R(t)},
  \quad \text{khi } B(t) = 0 \text{ và đang stall}.
  $$

Let:

- $t_{s,1}, t_{e,1}$: thời điểm bắt đầu và kết thúc stall thứ nhất;  
- $t_{s,i}, t_{e,i}$: stall thứ $i$;  

thì:

$$
T_{\text{stall,total}} = \sum_{i=1}^{N_{\text{stall}}} (t_{e,i} - t_{s,i}).
$$

Điểm quan trọng:

- Stall xảy ra khi tích lũy của **“thâm hụt”** bitrate so với throughput vượt quá buffer khởi đầu.  
- Nếu định nghĩa *deficit process*:

  $$
  Z(t) = \int_0^t \left( 1 - \frac{C(\tau)}{R(\tau)} \right) d\tau,
  $$

  thì stall xảy ra mỗi lần $Z(t)$ tăng tới mức $\ge B_{\text{start}}$ sau một reset (ignoring startup detail). Đây là một cách nhìn dưới góc nhìn **quá trình dồn tích** (accumulated deficit).

#### D.5.1.3. Mô hình xác suất cho stall

Một số nghiên cứu \[D37–D39] dùng mô hình xác suất:

- $C_k$ là biến ngẫu nhiên với phân phối $F_C(c)$;  
- $R_k$ được chọn từ tập $\mathcal{R}$ theo chính sách ABR;  
- $B_k$ là quá trình Markov được dẫn bởi $(R_k, C_k)$.

Mục tiêu là tính:

$$
P_{\text{stall}} = \mathbb{P}\left( \exists k: B_k = 0 \right), \quad \mathbb{E}[T_{\text{stall,total}}],
$$

hoặc ít nhất là xấp xỉ:

- Xác suất stall trong cửa sổ $T$;  
- Phân phối số lần stall $N_{\text{stall}}$.

Một xấp xỉ đơn giản (trong kịch bản stationarity) là:

- Giả sử $C_k$ i.i.d.,  
- $R_k = R$ cố định,  
- $B_k$ được khởi tạo ở $B_0 = B_{\text{start}}$.

Từ:

$$
B_{k+1} = \max\left\{0,\ B_k - \frac{R T_{\text{seg}}}{C_k}\right\} + T_{\text{seg}},
$$

bài toán trở thành đánh giá **hit probability** của 0 trong một random walk có drift dương/âm tuỳ thuộc $\mathbb{E}\left[\frac{R}{C_k}\right]$. Nếu:

$$
\mathbb{E}\left[\frac{R}{C_k}\right] < 1
\quad\Rightarrow\quad
\mathbb{E}[B_{k+1} - B_k] > 0,
$$

buffer **có xu hướng tăng**; stall hiếm – nhưng vẫn có thể xảy ra do fluctuation lớn. Ngược lại nếu $\mathbb{E}\left[\frac{R}{C_k}\right] \ge 1$, stall gần như chắc chắn xảy ra lâu dài.

Trên thực tế, ABR sẽ điều chỉnh $R_k$ dựa trên $B_k$ và $\hat{C}_k$ để tránh rơi vào vùng $\mathbb{E}\left[\frac{R_k}{C_k}\right] \ge 1$ quá lâu – đó chính là “bản chất toán học” đằng sau các thuật toán buffer-based như BBA/BOLA.

---

### D.5.2. Tác động của stall lên QoE người dùng

Nhiều khảo sát QoE đã chỉ ra:

- Stall là **“QoE killer” mạnh nhất** trong video streaming \[D37–D40].  
- Một hoặc hai lần stall ngắn ở đầu video có thể chấp nhận, nhưng stall dài hoặc lặp lại giữa video gây sụt giảm MOS lớn, tăng rời bỏ (abandon rate).

Ta sẽ mô hình hoá các hiệu ứng chính:

- Tần suất stall ($N_{\text{stall}}$).  
- Tổng thời gian stall ($T_{\text{stall,total}}$).  
- Vị trí stall (đầu, giữa, cuối).  
- Tương tác với chất lượng trung bình ($\bar{Q}$) và switching.

#### D.5.2.1. Mô hình penalty stall trong hàm QoE

Trong D.3, ta đã đưa một form QoE tổng quát:

- $Q_k$: chất lượng video (có thể là VMAF) của segment $k$.  
- $u(Q)$: hàm utility concave.  
- $T_{\text{stall,total}}$: tổng thời gian stall.  
- $\Delta Q_k = |Q_{k+1} - Q_k|$: lượng switching.

Mô hình:

$$
\text{QoE} = \sum_{k=1}^{K} u(Q_k) - \alpha_T T_{\text{stall,total}} - \alpha_S \sum_{k=1}^{K-1} \Delta Q_k - \alpha_L T_{\text{init}}.
$$

Một số nghiên cứu cụ thể hóa thành:

$$
\text{QoE} = \bar{Q} - \beta_1 \frac{T_{\text{stall,total}}}{T_{\text{video}}} - \beta_2 N_{\text{stall}} - \beta_3 T_{\text{init}} + \epsilon,
$$

trong đó \[D37–D39]:

- $\bar{Q}$: chất lượng trung bình;  
- $T_{\text{video}}$: độ dài video;  
- $\beta_1, \beta_2, \beta_3$: hệ số penalty được fit từ user study;  
- $\epsilon$: nhiễu (các yếu tố không quan sát được).

Kết quả điển hình:

- $\beta_1$ và $\beta_2$ thường **lớn hơn** hệ số chất lượng (tức là 1–2 giây stall tương đương việc giảm bitrate khá mạnh);  
- Stall ở **đầu video** ít gây phản cảm hơn stall giữa video, nhưng lại ảnh hưởng đến ấn tượng ban đầu; do vậy một số mô hình thêm weight theo vị trí.

Ví dụ đơn giản với weight vị trí:

- Gọi $w_i$ là weight của stall thứ $i$ với độ dài $\Delta t_i$, vị trí ở fraction $p_i \in [0,1]$ của video:

  $$
  \Phi_{\text{stall}} = \sum_{i=1}^{N_{\text{stall}}} w(p_i) \cdot \Delta t_i, 
  $$

  với hàm $w(p)$ tăng khi $p$ gần 1 (stall cuối video bị coi là phiền hơn), hoặc ngược lại tùy kết quả đo lường \[D40].

#### D.5.2.2. Ảnh hưởng đến hành vi người dùng (abandonment, engagement)

Các nghiên cứu trên trace thực (YouTube, Netflix, Akamai…) \[D37–D39] cho thấy:

- **Tỷ lệ rời bỏ (abandonment rate)** tăng mạnh theo số lần stall và thời gian stall:  
  - Một stall > 10 s ở giữa video có thể khiến phần lớn người dùng **bỏ xem**.  
  - Nhiều stall ngắn (1–2 s) liên tục cũng gây khó chịu hơn so với một stall dài nhưng ít lần.

- **Thời gian xem trung bình** giảm khi:

  - $T_{\text{stall,total}}$ tăng;  
  - $N_{\text{stall}}$ tăng;  
  - $T_{\text{init}}$ quá lớn (người dùng chờ lâu ở màn hình loading).

Một mô hình logistic cho xác suất người dùng rời bỏ ở thời điểm $t$ có thể viết:

- $P_{\text{leave}}(t)$: xác suất rời bỏ trong khoảng nhỏ quanh $t$;  
- $T_{\text{stall,cum}}(t)$: tổng thời gian stall tích lũy tới thời điểm $t$;  
- $\lambda_0(t)$: hazard base (tỷ lệ rời bỏ nền không do stall);  

Mô hình:

$$
P_{\text{leave}}(t) \approx 1 - \exp\left( - \left[ \lambda_0(t) + \lambda_{\text{stall}} T_{\text{stall,cum}}(t) \right] \Delta t \right),
$$

trong đó:

- $\lambda_{\text{stall}} > 0$ phản ánh việc **stall làm tăng hazard** rời bỏ.  

Khi $T_{\text{stall,cum}}$ tăng, xác suất rời bỏ tăng gần tuyến tính trong log-hazard.

#### D.5.2.3. Trade-off chất lượng vs stall

Giả sử ta xét hai cấu hình streaming:

- Cấu hình A:

  - Chất lượng trung bình $\bar{Q}_A$ cao;  
  - Tổng stall $T_{\text{stall},A}$ khá lớn.

- Cấu hình B:

  - Chất lượng trung bình $\bar{Q}_B$ thấp hơn;  
  - Stall gần như 0 ($T_{\text{stall},B} \approx 0$).

Nếu dùng mô hình:

$$
\text{QoE}_X = \bar{Q}_X - \beta T_{\text{stall},X}, \quad X\in\{A,B\},
$$

thì **B được ưu tiên** nếu:

$$
\bar{Q}_B - \beta T_{\text{stall},B} > \bar{Q}_A - \beta T_{\text{stall},A} \quad\Rightarrow\quad \bar{Q}_B - \bar{Q}_A > -\beta (T_{\text{stall},A} - T_{\text{stall},B}).
$$

Nếu $T_{\text{stall},B} \approx 0$:

$$
\bar{Q}_B - \bar{Q}_A > -\beta T_{\text{stall},A}.
$$

Vì $\beta$ thường lớn (theo các khảo sát, 1 giây stall có thể tương đương thiệt hại vài đơn vị chất lượng), thì dễ thấy:

- một **bitrate thấp hơn nhưng không stall** thường được người dùng đánh giá cao hơn **bitrate cao nhưng stall**;  
- đây là lý do các thuật toán ABR **ưu tiên “anti-stall”** trước, sau đó mới tăng chất lượng khi buffer an toàn.

#### D.5.2.4. Tích hợp stall vào các mô hình chuẩn (P.1203, VMAF + QoE)

- Trong **P.1203**, stall được đưa vào module tích hợp $P_q$ dưới dạng:

  - số lần stall $N_{\text{stall}}$,  
  - tổng thời gian stall $T_{\text{stall,total}}$,  
  - thời điểm stall,  

  và được ánh xạ qua các hàm penalty phi tuyến để tính MOS \[D17–D19, D24].

- Trong các nghiên cứu ABR sử dụng **VMAF** làm $Q_k$, thường:

  - $Q_k$ được lấy bằng VMAF của segment $k$ (không stall);  
  - Stall được đưa vào QoE như một **thành phần penalty riêng**, không thông qua VMAF:

    $$
    \text{QoE} = \sum_k u(\text{VMAF}_k) - \alpha_T T_{\text{stall,total}} - \alpha_S \sum_k |\text{VMAF}_{k+1} - \text{VMAF}_k|.
    $$

Do đó, khi đánh giá thuật toán ABR:

- Không thể chỉ tối đa hoá **VMAF trung bình** mà bỏ qua $T_{\text{stall,total}}$;  
- Cần tối ưu **hàm QoE đầy đủ**, có cả penalty cho stall và switching.

---

### Tài liệu tham khảo cho mục D.5 (định dạng IEEE)

\[D37] S. Akhshabi, A. C. Begen, and C. Dovrolis, “An experimental evaluation of rate-adaptation algorithms in adaptive streaming over HTTP,” in *Proc. ACM MMSys*, 2011, pp. 157–168.  

\[D38] J. De Vriendt, D. De Vleeschauwer, and D. Robinson, “Model for estimating QoE of video delivered using HTTP adaptive streaming,” in *Proc. Packet Video Workshop*, 2013, pp. 1–8.  

\[D39] F. Dobrian *et al.*, “Understanding the impact of video quality on user engagement,” in *Proc. ACM SIGCOMM*, 2011, pp. 362–373.  

\[D40] N. Bouten *et al.*, “Impact of video stalling on QoE of HTTP adaptive streaming,” in *Proc. IFIP/IEEE IM*, 2012, pp. 127–134.  

\[D41] ITU-T, *P.1203: Parametric Bitstream-based Quality Assessment of Progressive Download and Adaptive Audiovisual Streaming Services over Reliable Transport*, ITU-T Rec. P.1203, 2017.  

\[D42] W. Robitza *et al.*, “HTTP adaptive streaming QoE estimation with ITU-T Rec. P.1203: Open databases and software,” in *Proc. QoMEX*, 2018.  

\[D43] O. Oyman and S. Singh, “Quality of experience for HTTP adaptive streaming services,” *IEEE Commun. Mag.*, vol. 50, no. 4, pp. 20–27, Apr. 2012.
