## D.2. Mô hình buffer occupancy trong ABR

Trong adaptive streaming (MPEG-DASH, HLS), **buffer video phía client** là “bộ giảm chấn” giữa:

- quá trình **tải segment** với tốc độ phụ thuộc mạng, và  
- quá trình **phát video** với tốc độ phụ thuộc bitrate đã chọn.

Thiết kế thuật toán ABR thực chất là bài toán **điều khiển buffer**: lựa chọn bitrate $R_k$ sao cho buffer $B_k$:

- không rơi về $0$ (tránh stall),  
- không vượt quá một ngưỡng lớn (tránh lãng phí và tăng latency),  
- trong khi đạt được chất lượng trung bình cao và ít switching \[D9–D11].

Phần này xây dựng mô hình toán cho **diễn tiến buffer** và phân tích các điều kiện để **ổn định buffer, tránh stall**.

---

### D.2.1. Phương trình diễn tiến buffer

Ta sử dụng cả **mô hình rời rạc theo segment** và **mô hình liên tục (fluid model)**.

#### D.2.1.1. Mô hình rời rạc theo segment

Xét một luồng video được chia thành các segment có độ dài cố định $T_{\text{seg}}$ (giây). Tại decision thứ $k$ ($k = 1,2,\dots$):

- $R^{(m)}$: bitrate của representation thứ $m$ (bit/s). Tập bitrate:
  
  $$
  \mathcal{R} = \{ R^{(1)}, R^{(2)}, \dots, R^{(M)} \},\quad
  R^{(1)} < \dots < R^{(M)}.
  $$

- $m_k$: index bitrate được chọn tại segment $k$;  
- $R_k = R^{(m_k)}$: bitrate sử dụng tại segment $k$ (bit/s);  
- $S_k$: kích thước segment $k$ (bit), xấp xỉ:

  $$
  S_k \approx R_k \, T_{\text{seg}}.
  $$

- $C_k$: throughput thực “thấy được” trong quá trình tải segment $k$ (bit/s);  
- $D_k$: thời gian tải segment $k$ (s):

  $$
  D_k = \frac{S_k}{C_k} \approx \frac{R_k T_{\text{seg}}}{C_k}.
  $$

- $B_k$: mức buffer (giây video) **ngay trước** khi bắt đầu tải segment $k$.  
  Đây là lượng thời gian video mà player còn có thể phát nếu không tải thêm dữ liệu nào nữa.

##### (a) Trường hợp không stall trong segment $k$

Nếu $B_k > D_k$:

- Trong thời gian tải $D_k$, playback tiêu thụ $D_k$ giây video.  
- Khi segment tải xong, buffer được cộng thêm $T_{\text{seg}}$ giây.

Ta có:

$$
B_{k+1} = B_k - D_k + T_{\text{seg}}.
$$

Đặt:

- $\Delta B_k = B_{k+1} - B_k$ – biến thiên buffer trong decision $k$.

Khi không stall:

$$
\Delta B_k = T_{\text{seg}} - D_k = T_{\text{seg}} - \frac{R_k T_{\text{seg}}}{C_k}
           = T_{\text{seg}}\left(1 - \frac{R_k}{C_k}\right).
$$

Trực giác:

- Nếu $C_k > R_k$: $\Delta B_k > 0$ → buffer tăng;  
- Nếu $C_k < R_k$: $\Delta B_k < 0$ → buffer giảm.

##### (b) Trường hợp xảy ra stall trong segment $k$

Nếu $B_k \le D_k$:

- Buffer cạn sau $B_k$ giây, playback **dừng** (stall) cho đến khi segment tải xong.  
- Thời gian stall tại segment $k$:

  $$
  T_{\text{stall},k} = D_k - B_k.
  $$

- Sau khi tải xong, chứa thêm $T_{\text{seg}}$ giây video và buffer được “reset” về:

  $$
  B_{k+1} = T_{\text{seg}}.
  $$

Ta có thể viết quan hệ tổng quát:

$$
B_{k+1} = \max\{0,\ B_k - D_k\} + T_{\text{seg}},
$$

và thời gian stall:

$$
T_{\text{stall},k} = \max\{0,\ D_k - B_k\}.
$$

Tổng thời gian stall cả phiên:

$$
T_{\text{stall,total}} = \sum_{k=1}^K T_{\text{stall},k}.
$$

Trong nhiều bài toán tối ưu QoE \[D9–D11], $T_{\text{stall,total}}$ là một thành phần bị phạt rất mạnh.

##### (c) Viết lại theo dạng “tốc độ tương đối”

Khi không stall và bỏ qua saturation của buffer, ta có:

$$
B_{k+1} = B_k + T_{\text{seg}}\left(1 - \frac{R_k}{C_k}\right).$$

Đặt:

- $U_k = \frac{C_k}{R_k}$ – “tốc độ tương đối” giữa mạng và bitrate.

Khi $U_k > 1$: buffer có xu hướng tăng,  
khi $U_k < 1$: buffer có xu hướng giảm.

Dạng này rất thuận tiện cho phân tích ổn định: buffer ổn định nếu “trung bình” $U_k \ge 1$.

---

#### D.2.1.2. Mô hình liên tục (fluid model)

Để thuận tiện cho phân tích giải tích, nhiều công trình sử dụng **mô hình fluid** cho buffer \[D9, D10]:

- $B(t)$: buffer (giây video) tại thời điểm liên tục $t$;  
- $R(t)$: bitrate phát (bit/s) tại thời điểm $t$;  
- $C(t)$: throughput mạng (bit/s) tại thời điểm $t$;  
- $u(t)$: trạng thái tải dữ liệu (0 hoặc 1) – ở đây ta giả sử luôn tải khi buffer dưới một ngưỡng nhất định.

Trong khoảng thời gian nhỏ $\Delta t$ mà không đổi $R(t)$ và $C(t)$, lượng video thêm vào buffer (theo giây) là:

- Lượng bit tải được: $C(t)\,\Delta t$;  
- Số giây video tương ứng: $\frac{C(t)}{R(t)} \Delta t$.

Trong khi đó, playback tiêu thụ $\Delta t$ giây video (nếu đang play). Do đó, với trạng thái **đang play, không stall**, ta có phương trình vi phân:

$$
\frac{dB(t)}{dt} = \frac{C(t)}{R(t)} - 1.
$$

Khi $\frac{C(t)}{R(t)} > 1$ → $dB/dt > 0$: buffer tăng;  
khi $\frac{C(t)}{R(t)} < 1$ → $dB/dt < 0$: buffer giảm.

Trong các hệ thống có **giới hạn buffer tối đa** $B_{\max}$ (ví dụ để giới hạn latency):

- Nếu $B(t)$ đạt $B_{\max}$, client có thể **tạm dừng tải** (công tắc $u(t)$):

  - Khi $u(t)=1$ (đang tải): $dB/dt = \frac{C(t)}{R(t)} - 1$.  
  - Khi $u(t)=0$ (không tải): $dB/dt = -1$.

Đây là một hệ thống **hybrid**:

- Một pha: tích lũy (download) → buffer tăng;  
- Một pha: chỉ playback → buffer giảm.

Mô hình fluid cho phép sử dụng **công cụ điều khiển học** (control theory, Lyapunov, MPC) để thiết kế ABR \[D9].

---

#### D.2.1.3. Mô hình gắn với thuật toán ABR

Các thuật toán ABR định nghĩa một policy:

$$
R_k = f_{\text{ABR}}(B_k, \hat{C}_k, \text{state}_k),
$$

trong đó:

- $B_k$: buffer hiện tại;  
- $\hat{C}_k$: ước lượng throughput từ các mẫu lịch sử $C_i$;  
- $\text{state}_k$: các thông tin khác (bitrate lịch sử, QoE target, v.v.).

Một số ví dụ:

- **RB (rate-based)**:

  $$
  R_k = \max\{R^{(m)} \le \gamma \hat{C}_k\},
  $$

  với $0 < \gamma < 1$ là hệ số an toàn.

- **BB (buffer-based)**:

  $$
  R_k = f_{\text{BB}}(B_k),
  $$

  với $f_{\text{BB}}$ là hàm đơn điệu tăng.

- **BOLA**:

  $$
  R_k = \arg\max_m \Phi_m(B_k),
  $$

  trong đó $\Phi_m(B_k)$ cân bằng utility bitrate với mức đệm \[D11].

Nhúng $R_k$ vào phương trình diễn tiến buffer:

$$
B_{k+1} = \max\left\{0,\ B_k - \frac{R_k T_{\text{seg}}}{C_k}\right\} + T_{\text{seg}},
$$

ta thu được **một hệ động phi tuyến, bị nhiễu bởi $C_k$**, mà stability của nó phụ thuộc rất mạnh vào lựa chọn $f_{\text{ABR}}$.

Ở phần kế tiếp, ta phân tích **ổn định buffer** dưới các giả thiết đơn giản để rút ra trực giác thiết kế thuật toán.

---

### D.2.2. Ổn định buffer và tránh stall

Ta quan tâm đến các câu hỏi:

1. Điều kiện nào để buffer không “trôi dần về 0” (thiếu ổn định)?  
2. Target buffer nên đặt quanh giá trị nào để cân bằng **stall** và **latency**?  
3. Các thuật toán dựa trên buffer (BBA, BOLA) đảm bảo ổn định theo nghĩa nào?

#### D.2.2.1. Điều kiện cân bằng buffer (steady-state)

Giả sử đơn giản:

- Throughput $C_k = C$ gần như hằng số;  
- Bitrate $R_k = R$ không đổi;  
- Không stall (buffer không chạm 0).

Khi đó:

$$
B_{k+1} = B_k + T_{\text{seg}} \left(1 - \frac{R}{C}\right).
$$

Để buffer **không drift** theo thời gian, cần:

$$
\mathbb{E}[B_{k+1} - B_k] = 0
\quad\Rightarrow\quad
\mathbb{E}\left[1 - \frac{R}{C}\right] = 0.
$$

Trong trường hợp $C$ hằng số:

$$
1 - \frac{R}{C} = 0
\quad\Rightarrow\quad
R = C.
$$

Trên thực tế, ta không bao giờ chọn $R = C$ vì bất kỳ nhiễu nhỏ nào (dao động $C_k$) cũng làm buffer tụt. Do đó các thuật toán **luôn chèn một khoảng an toàn**:

$$
R \le \gamma C, \quad 0 < \gamma < 1.
$$

Khi đó:

$$
\mathbb{E}[B_{k+1} - B_k]
= T_{\text{seg}} (1 - \gamma) > 0,
$$

tức là buffer có xu hướng **tăng** (nếu không bị cắt bởi trần $B_{\max}$).  
Điều này đảm bảo **không stall**, nhưng lại có nguy cơ buffer quá lớn → latency tăng.

Với $C_k$ ngẫu nhiên, điều kiện để buffer **không drift xuống 0** trong dài hạn thường được viết:

$$
\mathbb{E}\left[\frac{R_k}{C_k}\right] \le 1.
$$

Điều này rất khó đảm bảo nếu $R_k$ chỉ phụ thuộc vào $\hat{C}_k$ “nhiễu” → cần bổ sung cơ chế buffer-based để tạo “phản hồi âm” khi buffer nhỏ.

---

#### D.2.2.2. Vùng an toàn của buffer và chiến lược “target buffer”

Trong các thuật toán buffer-based như BBA \[D10], ta chọn:

- $B_{\min}$: ngưỡng dưới – nếu $B_k < B_{\min}$, phải chọn bitrate thấp nhất $R^{(1)}$;  
- $B_{\max}$: ngưỡng trên – nếu $B_k > B_{\max}$, có thể chọn bitrate cao nhất $R^{(M)}$.

Khoảng $[B_{\min}, B_{\max}]$ được xem như **vùng kiểm soát (control region)**; phần ngoài vùng này là **vùng bảo vệ (safety region)**.

Một thiết kế điển hình:

- Nếu $B_k \le B_{\min}$:

  $$
  R_k = R^{(1)}.
  $$

- Nếu $B_k \ge B_{\max}$:

  $$
  R_k = R^{(M)}.
  $$

- Nếu $B_{\min} < B_k < B_{\max}$:

  $$
  R_k = f_{\text{lin}}(B_k)
  $$

với $f_{\text{lin}}$ ánh xạ tuyến tính buffer sang index bitrate.

Ý tưởng:

- Khi buffer xuống thấp, sử dụng bitrate thấp nhất để **đẩy $\Delta B_k$ dương** (vì $\frac{R^{(1)}}{C_k}$ nhỏ).  
- Khi buffer cao, có thể mạo hiểm chọn bitrate cao mà vẫn an toàn.

Nếu throughput trung bình $\mathbb{E}[C_k]$ đủ lớn so với $R^{(M)}$, thì buffer sẽ dao động chủ yếu trong vùng $[B_{\min}, B_{\max}]$, thay vì trôi về $0$.

---

#### D.2.2.3. Góc nhìn Lyapunov: ổn định buffer trong BOLA

BOLA \[D11] được thiết kế dựa trên **Lyapunov optimization**, với mục tiêu tối đa hóa utility QoE trong dài hạn mà vẫn đảm bảo buffer không thường xuyên rơi về 0.

Đặt:

- $Q_m = u(R^{(m)})$ – utility của bitrate $R^{(m)}$;  
- $L(B_k) = \frac{1}{2} B_k^2$ – Lyapunov function đo “energy” của buffer;  
- $V > 0$: tham số điều chỉnh trade-off **utility vs backlog**.

Tại mỗi bước $k$, BOLA chọn $m_k$ để **tối đa hóa**:

$$ \Phi_m(B_k) = \frac{V Q_m + \beta B_k}{S^{(m)}},$$

với $S^{(m)} \approx R^{(m)} T_{\text{seg}}$ và $\beta$ là hệ số được chọn sao cho buffer ổn định quanh một giá trị mong muốn.

Trực giác:

- Term $V Q_m$ khuyến khích chọn bitrate cao (tăng utility).  
- Term $\beta B_k$ gắn buffer vào quyết định:  
  - khi $B_k$ thấp, $\beta B_k$ nhỏ → ưu tiên bitrate thấp (vì $S^{(m)}$ lớn sẽ bị phạt);  
  - khi $B_k$ cao, $\beta B_k$ lớn → có thể chọn bitrate cao mà vẫn đạt giá trị $\Phi_m$ lớn.

Phân tích Lyapunov cho thấy:

- Độ lệch giữa utility đạt được và utility tối ưu là $O(1/V)$;  
- Buffer occupancy vẫn bị “giam” trong một biên phụ thuộc $V$ và các tham số khác.

Nói cách khác, BOLA **giữ buffer ổn định** quanh một phân bố giới hạn và đảm bảo QoE gần tối ưu mà không cần biết trước phân phối $C_k$.

---

#### D.2.2.4. Điều kiện tránh stall trong sense xác suất

Thay vì đòi hỏi **không bao giờ stall** (bất khả thi), ta thường đặt mục tiêu:

$$
\mathbb{P}\left(\min_{1 \le k \le K} B_k = 0\right) \le \varepsilon,
$$

hoặc đối với tổng thời gian stall:

$$
\mathbb{E}[T_{\text{stall,total}}] \le T_{\text{thresh}}.
$$

Trong mô hình fluid liên tục với $C(t)$ ngẫu nhiên, một xấp xỉ đơn giản (ổn định) là:

- Nếu tồn tại $R_{\text{eff}}$ sao cho:

  $$\liminf_{T \to \infty} \frac{1}{T} \int_0^T \frac{C(t)}{R_{\text{eff}}}\, dt > 1,$$

  thì buffer có xu hướng trôi về vùng “cao” với xác suất 1.  
- Nếu ABR đủ “bảo thủ” để không chọn $R_k$ quá gần $\sup C_k$, có thể đảm bảo $R_k \le R_{\text{eff}}$ với xác suất cao → giảm xác suất stall.

Trong thực nghiệm, các hệ thống thường:

- dùng **margin** (ví dụ chọn $R_k \le 0.85 \hat{C}_k$);  
- kết hợp buffer-based rule (giảm bitrate mạnh khi $B_k$ nhỏ) \[D9–D12];  
- chọn target buffer $B_{\text{target}}$ (ví dụ 20–30 s cho VoD, 3–10 s cho live OTT) để kiểm soát trade-off latency–stall.

---

#### D.2.2.5. Quan hệ với điều khiển dự đoán (MPC)

Trong framework **Model Predictive Control (MPC)** \[D9]:

- Mỗi decision $k$, ta xét **horizon $H$ segment**, dự báo throughput $C_{k},\dots,C_{k+H-1}$ (hoặc phân phối của chúng).  
- Với vector bitrate $\mathbf{q} = (q_k,\dots,q_{k+H-1})$, ta có thể **tính trước** buffer trajectory dự đoán $B_i^{\text{pred}}$ dựa trên:

  $$ B_{i+1}^{\text{pred}} = \max\left\{0,\ B_i^{\text{pred}} - \frac{R^{(q_i)} T_{\text{seg}}}{\hat{C}_i}\right\} + T_{\text{seg}}. $$

- Bài toán:

  $$\max_{\mathbf{q}} \left[ \sum_{i=k}^{k+H-1} u\big(R^{(q_i)}\big) - \alpha_T T_{\text{stall,pred}} - \alpha_S \sum_{i=k}^{k+H-2} |R^{(q_{i+1})} - R^{(q_i)}| \right]$$

  dưới ràng buộc $B_i^{\text{pred}} \ge 0$ (hoặc stall được phạt vào $T_{\text{stall,pred}}$).

Ở đây, buffer dynamics $B_i^{\text{pred}}$ đóng vai trò **trái tim của mô hình điều khiển**:

- Nếu policy chọn $R^{(q_i)}$ sao cho $B_i^{\text{pred}}$ rơi về 0 trong horizon → QoE rất thấp;  
- MPC sẽ tránh các dãy bitrate như vậy trừ khi phải hy sinh chất lượng tức thời để tránh stall.

Kết luận:

- Trong các scheme tiên tiến (MPC, DRL), buffer occupancy không chỉ là một scalar trạng thái, mà là **chuỗi trạng thái trong tương lai** được mô phỏng dựa trên mô hình diễn tiến nêu ở D.2.1;  
- Chính mô hình này làm cầu nối giữa **toán học (dynamical system)** và **chất lượng trải nghiệm**.

---

### Tài liệu tham khảo cho mục D.2 (định dạng IEEE)

\[D9] X. Yin, A. Jindal, V. Sekar, and B. Sinopoli, “A control-theoretic approach for dynamic adaptive video streaming over HTTP,” in *Proc. ACM SIGCOMM*, 2015, pp. 325–338.  

\[D10] T.-Y. Huang *et al.*, “A buffer-based approach to rate adaptation: Evidence from a large video streaming service,” in *Proc. ACM SIGCOMM*, 2014, pp. 187–198.  

\[D11] K. Spiteri, R. Urgaonkar, and R. K. Sitaraman, “BOLA: Near-optimal bitrate adaptation for online videos,” in *Proc. IEEE INFOCOM*, 2016, pp. 1–9.  

\[D12] K. Spiteri, R. Urgaonkar, and R. K. Sitaraman, “BOLA: Near-optimal bitrate adaptation for online videos,” *IEEE/ACM Trans. Netw.*, vol. 28, no. 4, pp. 1698–1711, Aug. 2020.  

\[D13] H. Mao, R. Netravali, and M. Alizadeh, “Neural adaptive video streaming with Pensieve,” in *Proc. ACM SIGCOMM*, 2017, pp. 197–210.  

\[D14] S. Akhshabi, A. C. Begen, and C. Dovrolis, “An experimental evaluation of rate-adaptation algorithms in adaptive streaming over HTTP,” in *Proc. ACM MMSys*, 2011, pp. 157–168.  

\[D15] S. Petrangeli, J. Famaey, S. Latré, and F. De Turck, “QoE-driven rate adaptation heuristics for HTTP adaptive streaming,” *ACM Trans. Multimedia Comput. Commun. Appl.*, vol. 12, no. 2, pp. 1–29, 2015.
