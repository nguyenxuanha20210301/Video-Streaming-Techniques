## D.6. Phân tích trade-off latency – quality – stability

Các phần D.1–D.5 đã lần lượt xây dựng:

- mô hình jitter và jitter buffer (D.1),  
- mô hình diễn tiến buffer trong ABR (D.2),  
- mô hình QoE (D.3),  
- congestion control TCP/WebRTC (D.4),  
- và stall (rebuffering) (D.5).

Phần D.6 có nhiệm vụ **kết nối** các mảnh ghép này thành một bức tranh thống nhất về trade-off giữa:

- **$L$ – latency** (startup delay, end-to-end delay),  
- **$Q$ – video quality** (bitrate, resolution, VMAF),  
- **$S$ – stability** (ít stall, ít switching, ít jitter).

Ta sẽ xây dựng một mô hình toán tổng quát, sau đó chuyên biệt cho hai lớp:

1. **HTTP adaptive streaming (DASH/HLS)**: VoD & live OTT.  
2. **Real-time streaming (WebRTC/RTP)**.

---

### D.6.1. Mô hình QoE ba chiều: $L$ – $Q$ – $S$

Ta xuất phát từ hàm QoE tổng quát (D.3, D.5), với ký hiệu:

- $Q_k$: chất lượng video tại segment/thời điểm $k$ (có thể là VMAF hoặc bitrate hiệu dụng).  
- $u(Q_k)$: hàm utility concave (thường dạng log hoặc tuyến tính bão hoà).  
- $T_{\text{stall,total}}$: tổng thời gian stall.  
- $N_{\text{stall}}$: số lần stall.  
- $\Delta Q_k = |Q_{k+1} - Q_k|$: độ lớn switching giữa hai đoạn liên tiếp.  
- $T_{\text{init}}$: startup delay;  
- $L_{\text{E2E}}$: latency end-to-end (đặc biệt cho live/real-time).  

Ta gom các thành phần lại trong một hàm QoE kỳ vọng:

$$
\mathbb{E}[\text{QoE}] = \underbrace{ \mathbb{E}\Big[\sum_{k=1}^{K} u(Q_k)\Big] }_{\text{thành phần chất lượng } Q} - \underbrace{ \alpha_T \mathbb{E}[T_{\text{stall,total}}] + \alpha_N \mathbb{E}[N_{\text{stall}}] }_{\text{thành phần stability – tránh stall}} - \underbrace{ \alpha_S \mathbb{E}\Big[\sum_{k=1}^{K-1} \Delta Q_k\Big] }_{\text{thành phần stability – tránh switching}} - \underbrace{ \alpha_L \mathbb{E}[L] }_{\text{thành phần latency}}, 
$$

trong đó $L$ có thể là:

- $L = T_{\text{init}}$ với VoD;  
- $L = L_{\text{E2E}}$ với live/real-time.

Các hệ số $\alpha_T, \alpha_N, \alpha_S, \alpha_L$ phản ánh **độ nhạy** của người dùng với từng yếu tố (ở P.1203 hay các mô hình regression, chúng được fit từ user study).

**Trade-off cơ bản**:

- Tăng $Q_k$ (bitrate cao, resolution lớn) → $u(Q_k)$ tăng, nhưng:

  - tăng $\mathbb{E}[T_{\text{stall,total}}]$ nếu mạng không đủ;  
  - có thể tăng switching (khi ABR phải giảm mạnh khi mạng xấu).

- Giảm $L$:

  - giảm $T_{\text{init}}$ bằng cách giảm buffer khởi tạo;  
  - hoặc giảm $L_{\text{E2E}}$ bằng cách giảm $B_{\text{live}}$, $D_{\text{pl}}$ (jitter buffer);  
  - nhưng làm hệ thống nhạy hơn với biến động throughput/jitter → tăng stall/freeze.

Không tồn tại cấu hình “tối ưu tuyệt đối” cho cả $Q$, $L$, $S$: ta chỉ có thể chọn **điểm nằm trên biên Pareto** của bộ ba này (C.4.2).

---

### D.6.2. Trade-off trong VoD ABR: startup buffer, bitrate và stall

Xét VoD trên HAS (DASH/HLS) với:

- $T_{\text{seg}}$: độ dài segment (giây).  
- $R_k$: bitrate chọn cho segment $k$.  
- $C_k$: throughput mạng trong khi tải segment $k$.  
- $B_k$: mức buffer (giây) trước khi tải segment $k$.  
- $B_{\text{start}}$: buffer khởi tạo (giây) – lượng dữ liệu cần tải trước khi play.  
- $T_{\text{init}}$: startup delay do buffer khởi tạo.

#### D.6.2.1. Latency khởi tạo vs độ an toàn buffer

Nếu ta khởi phát với bitrate gần như cố định $R$ trong giai đoạn startup, và throughput trung bình giai đoạn này là $\hat{C}$, thì:

- tỉ lệ $\frac{R}{\hat{C}}$ quyết định tốc độ “lấp” buffer;  
- lượng bit cần tải để buffer đạt $B_{\text{start}}$ là $R B_{\text{start}}$;  
- thời gian khởi tạo:

  $$
  T_{\text{init}}
  \approx
  \frac{R B_{\text{start}}}{\hat{C}}.
  $$

Như vậy:

- tăng $B_{\text{start}}$ → $T_{\text{init}}$ tăng *tuyến tính*, nhưng buffer an toàn hơn;  
- $B_{\text{start}}$ lớn → xác suất stall sớm (early stall) giảm mạnh (D.2, D.5).

Giả sử xác suất stall trong cả phiên xấp xỉ:

$$
P_{\text{stall}}
\approx
\exp(-\kappa B_{\text{start}}),\quad \kappa > 0.
$$

Trong một mô hình QoE đơn giản:

$$
\mathbb{E}[\text{QoE}] \approx U(R) - \alpha_L \frac{R B_{\text{start}}}{\hat{C}} - \alpha_T T_{\text{video}} P_{\text{stall}}(B_{\text{start}}),
$$

trong đó $U(R)$ là utility do chất lượng, $T_{\text{video}}$ độ dài video.

Ta có trade-off rõ:

- Term $-\alpha_L \frac{R B_{\text{start}}}{\hat{C}}$: ghét latency;  
- Term $-\alpha_T T_{\text{video}} e^{-\kappa B_{\text{start}}}$: ghét stall.

Nhìn vào đạo hàm theo $B_{\text{start}}$:

$$
\frac{\partial \mathbb{E}[\text{QoE}]}{\partial B_{\text{start}}} \approx - \alpha_L \frac{R}{\hat{C}} + \alpha_T T_{\text{video}} \kappa e^{-\kappa B_{\text{start}}}.
$$

Điều kiện tối ưu (giả sử tồn tại, bỏ qua biên):

$$
\alpha_L \frac{R}{\hat{C}} = \alpha_T T_{\text{video}} \kappa e^{-\kappa B_{\text{start}}^\star} \quad\Rightarrow\quad B_{\text{start}}^\star = \frac{1}{\kappa} \ln \left( \frac{\alpha_T T_{\text{video}} \kappa \hat{C}}{\alpha_L R} \right).
$$

Ý nghĩa:

- **Network xấu ($\hat{C}$ thấp)** → $B_{\text{start}}^\star$ tăng: phải pre-buffer nhiều hơn để tránh stall;  
- **Người dùng nhạy với stall ($\alpha_T$ lớn)** → $B_{\text{start}}^\star$ tăng;  
- **Người dùng nhạy với latency ($\alpha_L$ lớn)** → $B_{\text{start}}^\star$ giảm.

Trên thực tế, player thường chọn $B_{\text{start}}$ trong khoảng 1–5 giây tuỳ theo dạng nội dung (clip ngắn vs phim dài) và kiến trúc ABR.

#### D.6.2.2. Bitrate trung bình vs stall trong pha ổn định

Trong pha ổn định, ta dùng mô hình rời rạc:

$$
B_{k+1} = \max \left\{0,\ B_k - \frac{R_k T_{\text{seg}}}{C_k}\right\} + T_{\text{seg}}.
$$

Với ABR “tốt”, $R_k$ được chọn sao cho:

$$
\mathbb{E}\left[
  \frac{R_k}{C_k}
\right]
< 1,
$$

đảm bảo buffer có xu hướng **không drift xuống 0**.

Tuy nhiên, nếu ta “tham chất lượng” và chọn $R_k$ gần $\hat{C}_k$:

- ví dụ $R_k = \gamma \hat{C}_k$, $\gamma \to 1$,

thì về mặt kỳ vọng $\frac{R_k}{C_k} \approx \gamma \frac{\hat{C}_k}{C_k}$, mà $\frac{\hat{C}_k}{C_k}$ không luôn = 1 (do lỗi estimate). Khi $\gamma$ quá cao:

- $\mathbb{E}\left[ \frac{R_k}{C_k} \right] \to 1$ hoặc >1;  
- buffer trở nên “đi trên dây” → **nhạy stall**.

Ngược lại, chọn $\gamma$ thấp:

- đảm bảo $\mathbb{E}\left[ \frac{R_k}{C_k} \right] \ll 1$ → buffer luôn “dư” → stall gần như 0;  
- nhưng bitrate trung bình $\bar{R}$ thấp hơn nhiều so với năng lực mạng → chất lượng kém, lãng phí băng thông.

Trong các thuật toán như MPC/BOLA/Pensieve \[D9–D13], tham số tương đương $\gamma$ (hoặc $V$ trong BOLA) quyết định “độ tham chất lượng”:

- $V$ lớn → ưu tiên utility $u(Q_k)$, dễ chạm ngưỡng stall;  
- $V$ nhỏ → ưu tiên an toàn buffer, chất lượng vừa phải.

Kết quả thực nghiệm thường cho thấy:

- Tăng $V$ từ nhỏ đến vừa: QoE tăng do chất lượng tăng nhưng stall vẫn thấp;  
- Tăng $V$ quá lớn: QoE giảm vì stall bắt đầu xuất hiện nhiều.

---

### D.6.3. Trade-off trong Live/Low-latency OTT: delay, segment, buffer

Với live streaming OTT (HAS + CDN), latency tổng thể $L_{\text{live}}$ gồm:

- $L_{\text{enc}}$: latency encode (GOP, lookahead).  
- $L_{\text{seg}}$: latency do **segmentization** (chờ đủ mẫu để đóng segment).  
- $L_{\text{dist}}$: latency phân phối (CDN, cache).  
- $B_{\text{live}}$: playback buffer tại client.

Ta xấp xỉ:

$$
L_{\text{live}}
\approx
L_{\text{cap}} + L_{\text{enc}}
+
L_{\text{seg}}
+
L_{\text{dist}}
+
B_{\text{live}}.
$$

Với HLS/DASH truyền thống:

- $L_{\text{seg}} \approx n T_{\text{seg}}$ với $n \ge 2$–$3$ (phải đợi 2–3 segment để đảm bảo playback mượt, CDN cache ổn định);  
- $B_{\text{live}}$ có thể thêm 1–2 segment nữa;  
- tổng cộng dễ đạt 10–30 s latency.

Với LL-HLS/LL-DASH + CMAF:

- giảm $T_{\text{seg}}$ và dùng **chunk** (partial segment) độ dài $\approx$ 200–500 ms;  
- giảm $n$ xuống 1–2 chunk;  
- chơi trò đánh đổi:

  - $L_{\text{live}}$ có thể ~2–5 s, thậm chí sub-2 s;  
  - nhưng $B_{\text{live}}$ cũng giảm → **nhạy stall hơn** khi băng thông, jitter biến động.

#### D.6.3.1. Mô hình đơn giản cho $L_{\text{live}}$ vs $P_{\text{stall}}$

Giả sử:

- ta “chạy ahead” so với live edge một khoảng $B_{\text{live}}$ (giây);  
- throughput hiệu dụng trung bình là $\hat{C}$, fluctuation gây ra nhiễu $\epsilon(t)$;  
- $B_{\text{live}}$ đóng vai trò buffer để “đệm” variation.

Giữ $R$ cố định và dùng argument như D.2, D.5, xác suất stall trong một cửa sổ $T$ có thể xấp xỉ:

$$
P_{\text{stall}}
\approx
F\left(
  B_{\text{live}};
  \hat{C}, R, \text{Var}(C(t))
\right)
\sim
\exp\left(-\kappa' B_{\text{live}}\right).
$$

Mặt khác, $L_{\text{live}}$ gần như tuyến tính theo $B_{\text{live}}$:

$$
L_{\text{live}}
\approx
L_0 + B_{\text{live}},
$$

với $L_0 = L_{\text{cap}} + L_{\text{enc}} + L_{\text{seg}} + L_{\text{dist}}$.

Đặt QoE đơn giản:

$$
\mathbb{E}[\text{QoE}] \approx U(R) - \alpha_L L_{\text{live}} - \alpha_T P_{\text{stall}} T,
$$

thay $L_{\text{live}}$ và $P_{\text{stall}}$:

$$
\mathbb{E}[\text{QoE}] \approx U(R) - \alpha_L (L_0 + B_{\text{live}}) - \alpha_T T \exp(-\kappa' B_{\text{live}}).
$$

Đạo hàm theo $B_{\text{live}}$:

$$
\frac{\partial \mathbb{E}[\text{QoE}]}{\partial B_{\text{live}}} = - \alpha_L + \alpha_T T \kappa' \exp(-\kappa' B_{\text{live}}). 
$$

Điều kiện tối ưu:

$$
\alpha_L = \alpha_T T \kappa' \exp(-\kappa' B_{\text{live}}^\star) \quad\Rightarrow\quad B_{\text{live}}^\star = \frac{1}{\kappa'} \ln \left( \frac{\alpha_T T \kappa'}{\alpha_L} \right).
$$

- Nếu dịch vụ **nhắm tới latency thấp** (ví dụ live sport betting, e-sport), $\alpha_L$ lớn → $B_{\text{live}}^\star$ nhỏ;  
- Nếu dịch vụ **nhấn mạnh chất lượng & mượt** (xem phim live event), $\alpha_L$ nhỏ hơn → $B_{\text{live}}^\star$ lớn (chấp nhận delay 10–20 s).

Đây chính là bài toán **tối ưu target buffer** cho live mà các guideline thực tế (DASH-IF, Apple LL-HLS) đang giải quyết.

---

### D.6.4. Trade-off trong real-time (WebRTC/RTP): jitter buffer, bitrate, freeze

Với real-time (call, conference, game streaming), công thức tổng latency (C.3.4):

$$
L_{\text{E2E}} = T_{\text{cap}} + T_{\text{enc}} + T_{\text{pkt}} + T_{\text{net}} + T_{\text{jitt}} + T_{\text{dec}} + T_{\text{rend}}.
$$

Trong đó:

- $T_{\text{jitt}} = D_{\text{pl}}$: jitter buffer (playout delay).  
- Congestion control GCC điều khiển $R_{\text{send}}$ để giữ $T_{\text{net}}$ thấp (queue nhỏ).  
- Encoder có thể điều chỉnh $R_k, f_{\text{fps}}$.

#### D.6.4.1. Lựa chọn jitter buffer $D_{\text{pl}}$: delay vs late loss

Xem lại mô hình D.1.2:

- $d_i$: delay một chiều (bao gồm propagation + queueing) của gói $i$.  
- $D_{\text{pl}}$: playout delay (jitter buffer).  
- Điều kiện gói không đến muộn:

  $$
  d_i \le D_{\text{pl}}.
  $$

- Xác suất late loss:

  $$
  P_{\text{late}} = \mathbb{P}(d_i > D_{\text{pl}}).
  $$

Giả sử $d_i = \mu_d + \epsilon_i$, $\epsilon_i$ có độ lệch $\sigma_d$ (xấp xỉ Gaussian). Nếu chọn:

$$ 
D_{\text{pl}} = \mu_d + n\sigma_d,
$$

thì:

$$
P_{\text{late}}
\approx Q(n),
$$

với $Q(n)$ là tail Gaussian ($Q(2)\approx2.3\%, Q(3)\approx0.13\%$).

Đồng thời, contribution của jitter buffer vào latency:

$$
L_{\text{E2E}}
\approx
L_0 + D_{\text{pl}},
$$

với $L_0$ gộp các thành phần khác.

Giả sử người dùng “ghét” cả delay và freeze (do late loss), QoE được xấp xỉ:

- $Q_{\text{video}}$: chất lượng video (phụ thuộc bitrate, artifacts).  
- $\beta$: penalty mỗi đơn vị xác suất freeze/late;  
- $\gamma$: penalty mỗi ms delay.

$$
\text{QoE} \approx Q_{\text{video}} - \beta P_{\text{late}}(D_{\text{pl}}) - \gamma L_{\text{E2E}}.
$$

Thay vào:

$$
\text{QoE} \approx Q_{\text{video}} - \beta Q\left( \frac{D_{\text{pl}} - \mu_d}{\sigma_d} \right) - \gamma (L_0 + D_{\text{pl}}). 
$$

Đạo hàm theo $D_{\text{pl}}$:

$$
\frac{\partial \text{QoE}}{\partial D_{\text{pl}}} = - \beta \frac{\partial Q(n)}{\partial D_{\text{pl}}} - \gamma = - \beta \frac{1}{\sigma_d} \frac{\partial Q(n)}{\partial n} - \gamma. 
$$

Mà:

$$
\frac{\partial Q(n)}{\partial n} = -\frac{1}{\sqrt{2\pi}} e^{-n^2/2}.
$$

Do đó:

$$
\frac{\partial \text{QoE}}{\partial D_{\text{pl}}} = \beta \frac{1}{\sigma_d \sqrt{2\pi}} e^{-n^2/2} - \gamma.
$$

Tối ưu khi:

$$
\beta \frac{1}{\sigma_d \sqrt{2\pi}} e^{-n^2/2}
= \gamma.
$$

Lấy log:

$$
e^{-n^2/2} = \gamma \sigma_d \sqrt{2\pi} / \beta \quad\Rightarrow\quad n^\star = \sqrt{ -2 \ln \Big( \gamma \sigma_d \sqrt{2\pi} / \beta \Big) }. 
$$

Từ $n^\star$ suy ra $D_{\text{pl}}^\star = \mu_d + n^\star \sigma_d$.

Ý nghĩa:

- Nếu **người dùng/ứng dụng cực kỳ nhạy với latency** (ví dụ gaming cloud, live conversation), $\gamma$ lớn → $n^\star$ nhỏ → chọn jitter buffer gần $\mu_d$ (ít $n\sigma$) chấp nhận freeze cao hơn.  
- Nếu **chiều sâu hình ảnh quan trọng, freeze rất khó chấp nhận** (ví dụ concert, streaming chuyên nghiệp), $\beta$ lớn → $n^\star$ lớn → jitter buffer dài hơn, latency cao hơn.

Thực tế, WebRTC implementation thường có **adaptive jitter buffer**:

- Nâng $D_{\text{pl}}$ khi $J$ (jitter RTP) tăng;  
- Giảm $D_{\text{pl}}$ khi mạng ổn trong một thời gian;  
- Parameter tương đương $n$ được chọn dựa trên cấu hình ứng dụng (call, livestream, game…).

#### D.6.4.2. Congestion control (GCC) vs quality

Khi congestion, GCC giảm bitrate video $R_k$ để giữ delay thấp:

- lower $R_k$ → **chất lượng frame $Q_k$ giảm** (resolution/quantization).  
- nhưng giảm load mạng:

  - $T_{\text{net}}$ giảm;  
  - $\sigma_d$ (jitter) giảm;  
  - có thể giảm $D_{\text{pl}}$ mà không tăng $P_{\text{late}}$.

Có thể nhìn GCC như tối ưu một hàm:

$$
\max_{R_k} \mathbb{E}\Big[ u(Q_k) - \lambda L_{\text{E2E},k} \Big], 
$$

với $L_{\text{E2E},k}$ phụ thuộc vào queueing delay được đo qua trendline (D.4.2).

- Với **caller video** (chủ yếu tương tác): $\lambda$ lớn → GCC phải agresive giảm bitrate khi delay tăng.  
- Với **broadcast via WebRTC** (dùng WebRTC chỉ để giảm latency, không interactive nhiều): $\lambda$ có thể nhỏ hơn, chấp nhận queueing một chút để có bitrate cao hơn.

---

### D.6.5. Biên Pareto latency–quality–stability và thiết kế thuật toán

Để hình dung trade-off rõ hơn, ta xét **không gian hiệu năng**:

- trục $x$: latency $L$ (giảm càng tốt);  
- trục $y$: chất lượng $\bar{Q}$ (tăng càng tốt);  
- trục $z$: stability (ví dụ $-T_{\text{stall,total}}$ hoặc $-(\sum \Delta Q_k)$, càng cao càng tốt).

Mỗi thuật toán (ABR/RL/MPC/BOLA, hay GCC variant) tương ứng với một điểm:

$$
\mathbf{p}_i = (L_i, \bar{Q}_i, S_i).
$$

Một thuật toán $\mathbf{p}_1$ được coi **ưu thế tuyệt đối** so với $\mathbf{p}_2$ nếu:

- $L_1 \le L_2$, $\bar{Q}_1 \ge \bar{Q}_2$, $S_1 \ge S_2$  
- và ít nhất một bất đẳng thức nghiêm.

Tập các thuật toán mà **không bị thuật toán nào khác ưu thế tuyệt đối** chính là **biên Pareto**.

Minh hoạ 2D (một lát cắt bỏ qua $S$):

```text
Quality (Q)
  ^
  |                x   (Alg A: chất lượng cao, latency trung bình)
  |
  |         x
  |       (Alg B)
  |
  |   x
  | (Alg C: latency rất thấp, chất lượng vừa)
  +-----------------------------------------> Latency (L)
          (tốt)                    (xấu)
```

* Giả sử B nằm “lồi” so với A và C: B không bị A hoặc C ưu thế hoàn toàn → B nằm trên biên Pareto.
* Một thuật toán D nằm bên dưới đoạn nối A–C (chất lượng thấp hơn hoặc latency cao hơn cả hai) sẽ **bị dominated**.

Trong **thực nghiệm project**, ta có thể:

1. Chạy mô phỏng với nhiều cấu hình (ABR RB/BB/BOLA/MPC/Pensieve) trên cùng tập trace.

2. Đo:

   * $\bar{Q}_i$ (trung bình VMAF/bitrate),
   * $L_i$ (startup latency/live latency proxy),
   * $S_i$ (nghịch đảo stall và switching).

3. Vẽ các điểm $(L_i,\bar{Q}_i)$ hoặc $(L_i, \bar{Q}_i, S_i)$, đánh dấu **biên Pareto**.

**Insight thiết kế**:

* Nếu muốn **dịch vụ live thể thao phổ thông**:

  * chấp nhận latency 4–6 s, ưu tiên $\bar{Q}$ và $S$ cao → chọn thuật toán nằm vùng “latency trung bình–QoE cao, ổn định”.
* Nếu muốn **dịch vụ auction/betting**:

  * latency phải < 2 s, chấp nhận QoE thấp hơn chút → chọn thuật toán dịch về phía $L$ thấp dù $\bar{Q}$ giảm.
* Với **VoD mobile**:

  * người dùng ghét stall khi đang đi tàu/bus → ưu tiên $S$ (anti-stall) hơn $\bar{Q}$, latency startup có thể ~2–3 s.

---

### D.6.6. Hệ quả cho thiết kế hệ thống và project

Từ toàn bộ phân tích trên, có thể rút ra một số nguyên tắc cho thiết kế và đánh giá trong project:

1. **Phải rõ kịch bản dịch vụ** trước khi chọn thuật toán:

   * VoD vs live vs real-time;
   * interactive vs non-interactive;
   * thiết bị (mobile, TV, PC), loại nội dung (phim, sport, game).

   Mỗi kịch bản tương ứng với cấu hình trọng số $(\alpha_T, \alpha_S, \alpha_L)$ khác nhau.

2. **Buffer là biến điều khiển trung tâm**:

   * $B_{\text{start}}, B_{\text{target}}, B_{\text{live}}$ và jitter buffer $D_{\text{pl}}$ quyết định trade-off $L$–$S$.
   * ABR, GCC và jitter buffer đều là **bộ điều khiển** tác động tới các buffer này.

3. **Đánh giá thuật toán phải đa chiều**:

   * Không chỉ nhìn vào bitrate trung bình $\bar{R}$ hoặc PSNR/VMAF;
   * Phải log: $T_{\text{stall,total}}$, $N_{\text{stall}}$, phân phối $L$, profile switching;
   * Sử dụng mô hình QoE như P.1203 hoặc dạng tổng quát (D.3) làm thước đo hợp nhất.

4. **Hướng nghiên cứu nâng cao**:

   * Học sâu (Pensieve, RL-based ABR) thực chất là học ra policy $R_k = f(s_k)$ tối ưu hàm QoE đa thành phần;
   * Có thể mở rộng thêm dimension latency và stability rõ ràng hơn (multi-objective RL) [D9–D13].
   * Cho real-time, có thể kết hợp GCC + học sâu ở tầng ứng dụng (ví dụ chọn resolution/framerate tối ưu dựa trên feedback của CC).

Các ý tưởng này sẽ được khai thác trong phần E (thiết kế mô phỏng) khi so sánh các thuật toán ABR/GCC dưới các kịch bản khác nhau, nhằm minh hoạ **biên Pareto latency–quality–stability** một cách định lượng.

---

### Tài liệu tham khảo cho mục D.6 (định dạng IEEE)

[D44] X. Yin, A. Jindal, V. Sekar, and B. Sinopoli, “A control-theoretic approach for dynamic adaptive video streaming over HTTP,” in *Proc. ACM SIGCOMM*, 2015.

[D45] T.-Y. Huang *et al.*, “A buffer-based approach to rate adaptation: Evidence from a large video streaming service,” in *Proc. ACM SIGCOMM*, 2014.

[D46] K. Spiteri, R. Urgaonkar, and R. K. Sitaraman, “BOLA: Near-optimal bitrate adaptation for online videos,” in *Proc. IEEE INFOCOM*, 2016.

[D47] H. Mao, R. Netravali, and M. Alizadeh, “Neural adaptive video streaming with Pensieve,” in *Proc. ACM SIGCOMM*, 2017.

[D48] F. Dobrian *et al.*, “Understanding the impact of video quality on user engagement,” in *Proc. ACM SIGCOMM*, 2011.

[D49] N. Bouten *et al.*, “Impact of video stalling on QoE of HTTP adaptive streaming,” in *Proc. IFIP/IEEE IM*, 2012.

[D50] O. Oyman and S. Singh, “Quality of experience for HTTP adaptive streaming services,” *IEEE Commun. Mag.*, vol. 50, no. 4, 2012.

[D51] ITU-T, *P.1203: Parametric Bitstream-based Quality Assessment of Progressive Download and Adaptive Audiovisual Streaming Services over Reliable Transport*, ITU-T Rec. P.1203, 2017.

[D52] G. Carlucci, L. De Cicco, S. Holmer, and S. Mascolo, “Analysis and design of the Google congestion control for Web real-time communication (WebRTC),” *Computer Networks*, vol. 136, 2018.

