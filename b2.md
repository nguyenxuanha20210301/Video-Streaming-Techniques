## B.2. Cấu trúc video và dòng dữ liệu

### B.2.1. GOP, frame I/P/B

Trong hầu hết các chuẩn nén video hiện đại (MPEG-2, H.264/AVC, H.265/HEVC, AV1), cấu trúc chuỗi ảnh được tổ chức theo **GOP – Group of Pictures**. GOP là một dãy khung hình liên tiếp, thường lặp lại theo một mẫu cố định (pattern), ví dụ:

- `I B B P B B P B B I ...`  
- `I P B B P B B P ...`

trong đó các loại frame cơ bản gồm \[B3, B6, B11]:

- **I-frame (Intra-coded frame):**  
  - Được mã hóa hoàn toàn bằng dự đoán nội khung (intra prediction).  
  - Không phụ thuộc vào frame khác → là điểm truy cập ngẫu nhiên (random access point).  
  - Thường có bitrate cao nhất trong GOP.  

- **P-frame (Predictive-coded frame):**  
  - Được dự đoán từ một hoặc nhiều frame quá khứ (thông thường là I hoặc P trước đó) thông qua bù chuyển động (inter prediction).  
  - Chỉ dùng **forward prediction**.  
  - Bitrate thấp hơn I-frame do sử dụng tương quan thời gian.  

- **B-frame (Bi-predictive frame):**  
  - Được dự đoán từ cả frame quá khứ và tương lai (bi-directional prediction).  
  - Mức độ nén cao nhất (bitrate thấp nhất) nhờ tận dụng tương quan hai phía.  
  - Cần **reordering**: thứ tự truyền/giải mã khác thứ tự hiển thị.  

Một GOP hoàn chỉnh thường bắt đầu bằng một I-frame, theo sau là các P/B frame. Ta có thể mô hình hóa một GOP với chiều dài \(N_{\text{GOP}}\) (tính theo số frame) như sau:

$$
\mathcal{G} = \{ F_0, F_1, \ldots, F_{N_{\text{GOP}}-1} \}
$$

trong đó:

- \(F_0\) là I-frame;  
- Các frame còn lại \(F_i\) (\(i \ge 1\)) là P hoặc B tuỳ theo cấu hình.

Ký hiệu **tỉ lệ các loại frame** trong một GOP như:

- \(N_I\): số I-frame (thường \(N_I = 1\));  
- \(N_P\): số P-frame;  
- \(N_B\): số B-frame;

ta có:

$$
N_{\text{GOP}} = N_I + N_P + N_B
$$

Tổng bitrate trung bình của một GOP có thể được xấp xỉ bởi:

$$
R_{\text{GOP}} 
\approx \frac{1}{T_{\text{GOP}}}
\left(
N_I \cdot S_I +
N_P \cdot S_P +
N_B \cdot S_B
\right)
$$

trong đó:

- \(S_I, S_P, S_B\): kích thước trung bình (bit) của một I, P, B frame;  
- \(T_{\text{GOP}} = \frac{N_{\text{GOP}}}{f}\) là thời lượng thời gian tương ứng với một GOP, với \(f\) là framerate (fps).

**Chiều dài GOP** là một tham số quan trọng:

- GOP dài (ví dụ 2 giây, 3 giây):  
  - Hiệu quả nén tốt hơn (ít I-frame, nhiều B/P frame).  
  - Truy cập ngẫu nhiên kém hơn, khi seek hoặc join stream phải chờ đến I-frame tiếp theo.  
- GOP ngắn (1 giây hoặc nhỏ hơn):  
  - Hỗ trợ tốt cho các ứng dụng streaming tương tác, ABR, low-latency.  
  - Overhead tăng do xuất hiện nhiều I-frames hơn.

Trong thực tế, các hệ thống streaming HTTP (DASH/HLS) thường chọn **GOP duration** xấp xỉ độ dài segment (ví dụ 2 s, 4 s) để đơn giản hóa đóng gói, tuy nhiên các cấu hình low-latency có thể dùng GOP nhỏ hơn, thậm chí sử dụng **open-GOP**/B-frame xuyên segment với các cơ chế đặc thù.

---

### B.2.2. Bitrate, framerate, resolution

Ba tham số cơ bản mô tả đặc tính kỹ thuật của một video:

- **Resolution (độ phân giải)**  
- **Framerate (tần số khung hình)**  
- **Bitrate (tốc độ bit)**

#### B.2.2.1. Độ phân giải (resolution)

Độ phân giải không gian được đặc trưng bởi số lượng điểm ảnh theo chiều ngang và dọc:

$$
\text{Resolution} = W \times H
$$

Ví dụ phổ biến:

- 1280×720 (HD, 720p)  
- 1920×1080 (Full HD, 1080p)  
- 3840×2160 (4K UHD)  

Số điểm ảnh mỗi frame:

$$
N_{\text{pix}} = W \cdot H
$$

Với cùng codec và cùng mức chất lượng chủ quan, video có độ phân giải cao hơn sẽ cần bitrate cao hơn để mã hóa chi tiết không gian.

#### B.2.2.2. Framerate (fps)

Framerate \(f\) là số frame được hiển thị trong một giây, thường là:

- 24 fps (phim);  
- 25 fps (PAL/Europe);  
- 30 fps (NTSC/US);  
- 50/60 fps (nội dung thể thao, game).

Thời lượng một frame:

$$
T_{\text{frame}} = \frac{1}{f}
$$

Thời lượng một GOP:

$$
T_{\text{GOP}} = \frac{N_{\text{GOP}}}{f}
$$

Framerate cao giúp chuyển động mượt mà hơn, nhưng với cùng mức chất lượng mỗi frame, bitrate cần thiết sẽ tăng gần tuyến tính theo \(f\).

#### B.2.2.3. Bitrate và mối quan hệ với kích thước frame

Với video đã được nén, **bitrate trung bình** \(R\) (bit/s) có thể được tính từ tổng kích thước file hoặc stream:

$$
R = \frac{S_{\text{total}}}{T_{\text{video}}}
$$

trong đó:

- \(S_{\text{total}}\): tổng số bit của toàn bộ video;  
- \(T_{\text{video}}\): thời lượng video (s).

Nếu \(R_{\text{avg}}\) là bitrate trung bình, mỗi frame có kích thước trung bình (bit):

$$
\bar{S}_{\text{frame}} = \frac{R_{\text{avg}}}{f}
$$

Tuy nhiên, do đặc tính GOP, kích thước frame không cố định mà dao động theo loại frame:

- \(S_I > S_P > S_B\).

Ta có thể biểu diễn bitrate trung bình theo kiểu frame:

$$
R_{\text{avg}} 
= f \left(
\alpha_I S_I + \alpha_P S_P + \alpha_B S_B
\right)
$$

trong đó \(\alpha_x\) là **tỉ lệ** số frame loại \(x\) trong chuỗi:

$$
\alpha_I = \frac{N_I}{N_{\text{GOP}}},\quad
\alpha_P = \frac{N_P}{N_{\text{GOP}}},\quad
\alpha_B = \frac{N_B}{N_{\text{GOP}}}
$$

và:

$$
\alpha_I + \alpha_P + \alpha_B = 1
$$

Hệ thống **rate control** trong encoder (CBR/VBR) sẽ điều chỉnh tham số lượng tử (QP) theo thời gian để giữ \(R_{\text{avg}}\) gần với mục tiêu, đồng thời tôn trọng ràng buộc buffer của hệ thống (VBV/HRD).

---

### B.2.3. Mô hình buffer phát video (playback buffer)

Trong truyền dòng video (đặc biệt là streaming qua mạng IP), **buffer phía client** là thành phần then chốt để che giấu biến động mạng (jitter, throughput thay đổi) và hạn chế hiện tượng stall (rebuffering).

Xét một mô hình buffer trừu tượng:

- \(B(t)\): lượng dữ liệu trong buffer tại thời điểm \(t\), đơn vị là giây phát (playout seconds) hoặc số lượng bit/byte.  
- \(r_{\text{in}}(t)\): tốc độ dữ liệu vào buffer (download rate), đơn vị bit/s hoặc giây phát/s.  
- \(r_{\text{out}}(t)\): tốc độ tiêu thụ (playout rate), thông thường là bitrate diễn giải sang đơn vị giây phát/s.

#### B.2.3.1. Mô hình fluid theo thời gian liên tục

Nếu ta đo \(B(t)\) theo **đơn vị giây playback** (tức là “bao nhiêu giây video đang tồn trong buffer”), mô hình động lực hay dùng là:

$$
\frac{dB(t)}{dt}
= r_{\text{in}}(t) - 1,\quad B(t) \ge 0
$$

trong đó:

- \(r_{\text{in}}(t)\) là tốc độ **nạp buffer** tính theo “giây video trên giây thời gian thực”;  
- giả sử tốc độ **tiêu thụ buffer** là 1 giây video / giây thời gian (khi playback chạy bình thường).

Khi mạng tốt, \(r_{\text{in}}(t) > 1\):

- buffer tăng dần, giúp chống chịu được các giai đoạn mạng xấu sau đó.

Khi mạng xấu, \(r_{\text{in}}(t) < 1\):

- buffer bị rút dần; nếu \(B(t)\) chạm 0 thì xảy ra **stall** và trình phát phải dừng (hoặc hiển thị “đang tải”).

Trong hệ thống ABR, \(r_{\text{in}}(t)\) phụ thuộc vào:

- bitrate representation đang được chọn;  
- điều kiện mạng tức thời;  
- cơ chế TCP/HTTP và scheduling segment.

#### B.2.3.2. Mô hình rời rạc theo segment

Đối với **HTTP adaptive streaming**, dữ liệu thường được tải theo đơn vị **segment** (ví dụ độ dài 2 s, 4 s). Giả sử:

- Segment thứ \(k\) có độ dài thời gian \(T_{\text{seg}}\) (s) và bitrate được chọn là \(R_k\) (bit/s).  
- Thời gian tải segment thứ \(k\) là \(D_k\) (s).  
- **Throughput hiệu dụng** trong khoảng tải segment là:

  $$
  C_k = \frac{R_k T_{\text{seg}}}{D_k}
  $$

ta có quan hệ buffer rời rạc (theo giây playback):

$$
B_{k+1} 
= \max\left\{0,\ B_k - D_k\right\} + T_{\text{seg}}
$$

- Trong khoảng thời gian tải segment \(k\) (mất \(D_k\) giây thực), buffer bị “tiêu” \(D_k\) giây phát (nếu playback đang chạy).  
- Khi tải xong, buffer được tăng thêm đúng độ dài nội dung của segment \((T_{\text{seg}})\).

Trong trường hợp **stalling có thể xảy ra**, mô hình tinh hơn là:

- Nếu \(B_k > D_k\): không stall trong khi tải segment, công thức trên giữ nguyên.  
- Nếu \(B_k \le D_k\): buffer tụt về 0 trước khi tải xong, playback dừng, và tổng thời gian stall xảy ra trong khoảng đó là:

  $$
  T_{\text{stall},k} = D_k - B_k
  $$

  buffer sau khi tải xong segment:

  $$
  B_{k+1} = T_{\text{seg}}
  $$

Đây là mô hình nền tảng được dùng rất nhiều trong các công trình phân tích ABR và QoE \[B12–B14].

#### B.2.3.3. Mối quan hệ buffer – bitrate – QoE

Từ mô hình buffer rời rạc, các thuật toán ABR thường tối ưu trade-off giữa:

- **bitrate trung bình** (chất lượng video);  
- **biến động bitrate** (mức độ switching);  
- **thời gian stall**;  
- **trạng thái buffer** (ổn định, tránh chạm 0).

Một dạng hàm QoE tổng quát cho một phiên xem gồm \(K\) segment có thể được viết:

$$
\text{QoE} 
= \sum_{k=1}^{K} u(Q_k)
- \alpha \sum_{k=1}^{K-1} |Q_{k+1} - Q_k|
- \beta \cdot T_{\text{stall,total}}
$$

trong đó \[B12–B14]:

- \(Q_k\): “mức chất lượng” hoặc bitrate tương ứng với segment \(k\);  
- \(u(\cdot)\): hàm utility (thường là concave, ví dụ \(u(Q) = \log(Q)\) hoặc \(u(Q) \propto \text{VMAF}\));  
- \(\alpha\): hệ số phạt cho switching chất lượng;  
- \(\beta\): hệ số phạt cho tổng thời gian stall \(T_{\text{stall,total}}\).

Quan hệ này minh họa cách buffer và bitrate quyết định QoE:

- Bitrate cao → \(u(Q_k)\) lớn, nhưng dễ gây stall nếu không phù hợp với throughput;  
- Giữ buffer cao (chọn bitrate “an toàn”) giảm stall, nhưng QoE có thể kém do chất lượng thấp;  
- Switching quá nhiều (lên/xuống bitrate liên tục) cũng làm QoE giảm.

Trong các phần sau (mục C.2, D.2, D.5), các mô hình toán chi tiết hơn về **buffer dynamics**, **thuật toán ABR** và **QoE** sẽ được khai thác dựa trên nền tảng B.2.3 này.

---

### Tài liệu tham khảo cho mục B.2 (định dạng IEEE)

\[B3] T. Wiegand, G. J. Sullivan, G. Bjøntegaard, and A. Luthra, “Overview of the H.264/AVC video coding standard,” *IEEE Trans. Circuits Syst. Video Technol.*, vol. 13, no. 7, pp. 560–576, Jul. 2003.  

\[B6] G. J. Sullivan, J.-R. Ohm, W.-J. Han, and T. Wiegand, “Overview of the High Efficiency Video Coding (HEVC) standard,” *IEEE Trans. Circuits Syst. Video Technol.*, vol. 22, no. 12, pp. 1649–1668, Dec. 2012.  

\[B11] I. E. G. Richardson, *H.264 and MPEG-4 Video Compression: Video Coding for Next-generation Multimedia*, Wiley, 2003.  

\[B12] T.-Y. Huang *et al.*, “A buffer-based approach to rate adaptation: Evidence from a large video streaming service,” in *Proc. ACM SIGCOMM*, 2014, pp. 187–198.  

\[B13] X. Yin, A. Jindal, V. Sekar, and B. Sinopoli, “A control-theoretic approach for dynamic adaptive video streaming over HTTP,” in *Proc. ACM SIGCOMM*, 2015, pp. 325–338.  

\[B14] X. Yin, V. Sekar, and B. Sinopoli, “Toward a principled framework to design dynamic adaptive streaming algorithms over HTTP,” in *Proc. ACM HotNets*, 2014, pp. 1–7.
