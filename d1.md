## D.1. Jitter trong RTP (theo RFC 3550)

Trong truyền thông thời gian thực (VoIP, video conference, WebRTC…), **jitter** là một trong các yếu tố mạng quan trọng nhất, trực tiếp chi phối cách thiết kế **jitter buffer** và từ đó ảnh hưởng tới **độ trễ end-to-end** và **QoE**. Mặc dù phần B.4 đã giới thiệu khái niệm jitter ở mức tổng quan, trong mục này ta đi sâu vào:

- Định nghĩa và công thức tính jitter **chuẩn theo RFC 3550** cho RTP.  
- Mối quan hệ giữa jitter, jitter buffer và QoE video/âm thanh.

---

### D.1.1. Công thức tính jitter (RTP Interarrival Jitter)

#### D.1.1.1. Khung thời gian RTP và thời gian đến thực tế

Xét một phiên RTP, ta ký hiệu:

- $S_i$: RTP timestamp của gói thứ $i$.

  - Đơn vị: “tick” của **clock RTP** (ví dụ $90\,000$ Hz cho video, $48\,000$ Hz cho audio).  
  - $S_i$ phản ánh **thời gian trình chiếu (presentation time)** theo clock encoder.

- $R_i$: thời gian đến (arrival time) của gói thứ $i$ tại receiver, chuyển về **cùng đơn vị** với $S_i$ bằng cách nhân với clock rate.  
  Ví dụ: nếu $t_i$ là thời gian thực (seconds since reference), clock media có tần số $f_s$ (Hz), thì:

  $$
  R_i = t_i \cdot f_s.
  $$

Khi đường truyền lý tưởng (không jitter, không delay variation):

- khoảng cách thời gian tại sender và receiver trùng nhau:

  $$
  (R_j - R_i) \approx (S_j - S_i),\quad \forall i,j.
  $$

Khi có jitter, do queueing, routing,… khoảng cách tại receiver bị méo:

- $(R_j - R_i)$ khác $(S_j - S_i)$.

Để đo mức méo này, RFC 3550 định nghĩa **relative transit time**:

- $D(i,j)$: sai lệch giữa “thời gian đi” (transit time) của hai gói $i$ và $j$.

  $$
  D(i,j) = (R_j - R_i) - (S_j - S_i)
        = (R_j - S_j) - (R_i - S_i).
  $$

Ở đây:

- $R_j - S_j$ là “thời gian transit” (từ lúc gói được timestamp đến lúc tới receiver) tính trong đơn vị clock;  
- $D(i,j)$ chính là **sự thay đổi** của thời gian transit giữa hai gói.

#### D.1.1.2. Công thức đệ quy tính jitter theo RFC 3550

RFC 3550 không dùng độ lệch chuẩn (standard deviation) trực tiếp mà sử dụng một **bộ lọc mũ bậc nhất (exponential filter)** để ước lượng jitter online. Ta ký hiệu:

- $D_i = D(i-1,i)$ – relative transit time giữa gói thứ $i-1$ và $i$:

  $$
  D_i = (R_i - R_{i-1}) - (S_i - S_{i-1}).
  $$

- $J_i$: giá trị jitter ước lượng sau khi xử lý gói thứ $i$.

Công thức đệ quy:

$$
J_i = J_{i-1} + \frac{|D_i| - J_{i-1}}{16}.
$$

Trong đó:

- $J_0$ có thể khởi tạo bằng $0$ hoặc bằng $|D_1|$ cho gói đầu tiên;  
- hệ số $\frac{1}{16}$ đóng vai trò là **hệ số learning** trong bộ lọc EMA, tương ứng với hệ số “forgetting factor”:

  $$
  \alpha = \frac{1}{16},\quad
  J_i = (1 - \alpha)J_{i-1} + \alpha |D_i|.
  $$

Đây là một dạng **trung bình trượt mũ** (exponential moving average) của $|D_i|$.

Giải thích:

- $|D_i|$ đo “biên độ jitter tức thời” giữa hai gói liên tiếp.  
- $J_i$ là **jitter đã làm trơn**, ít nhạy với spike ngắn, phản ánh xu hướng jitter dài hạn.  
- Hệ số $1/16$ tương đương “cửa sổ hiệu dụng” khoảng 16 mẫu.

Để chuyển jitter từ đơn vị clock sang giây:

- nếu clock rate là $f_s$ (Hz), jitter theo giây:

  $$
  J_i^{(\text{s})} = \frac{J_i}{f_s}.
  $$

Ví dụ:

- với video RTP, $f_s = 90\,000$ Hz;  
- nếu $J_i = 900$ → $J_i^{(\text{s})} = \frac{900}{90\,000} = 0.01$ s = $10$ ms.

#### D.1.1.3. Mối liên hệ với thống kê cổ điển (variance, std)

Trong thống kê cổ điển, nếu $d_i$ là “delay” từng gói, jitter có thể được định nghĩa như:

- Độ lệch chuẩn:

  $$
  \sigma_d = \sqrt{\frac{1}{N-1}\sum_{i=1}^N (d_i - \bar{d})^2},\quad
  \bar{d} = \frac{1}{N}\sum_{i=1}^N d_i.
  $$

- Hoặc mean absolute deviation:

  $$
  J_{\text{MAD}} = \frac{1}{N}\sum_{i=1}^N |d_i - \bar{d}|.
  $$

Nếu ta coi $|D_i|$ trong RFC 3550 là một “ước lượng local” của $|d_i - \bar{d}|$, thì $J_i$ chính là một phiên bản **online, incremental** của $J_{\text{MAD}}$ được cập nhật mỗi gói mà không cần lưu toàn bộ lịch sử.

Ngoài ra, do $D_i = (R_i - R_{i-1}) - (S_i - S_{i-1})$ liên quan đến **sai khác khoảng cách thời gian**, nên công thức trên nhạy với biến thiên delay mà **ít phụ thuộc** vào absolute offset.

#### D.1.1.4. Jitter trong RTCP Receiver Report

Giá trị $J_i$ được báo cáo định kỳ trong các gói **RTCP RR (Receiver Report)**, cụ thể trường `interarrival jitter` trong khối report. Khi thu thập nhiều RR từ nhiều receiver khác nhau, sender (hoặc hệ thống giám sát) có thể:

- Quan sát mức jitter toàn mạng;  
- Điều chỉnh bitrate, FEC, pacing;  
- Phát hiện vùng mạng có queueing bất thường.

Ký hiệu:

- $J^{(r)}$: jitter báo cáo bởi receiver $r$;  
- nếu có $N_r$ receiver, có thể tính **jitter trung bình**:

  $$
  \bar{J} = \frac{1}{N_r}\sum_{r=1}^{N_r} J^{(r)},
  $$

và **jitter cực đại**:

  $$
  J_{\max} = \max_{1 \le r \le N_r} J^{(r)}.
  $$

Các metric này thường được log tại media server/SFU để đánh giá chất lượng dịch vụ theo vùng địa lý, ISP, thời gian trong ngày,…

---

### D.1.2. Ảnh hưởng của jitter đến QoE

Jitter không trực tiếp “hiện lên màn hình” như mất gói hay bit-error, nhưng nó ảnh hưởng mạnh đến **buffer thiết kế** và **độ trễ**. Để phân tích, ta xem xét mối liên hệ:

- Jitter → Thiết kế **jitter buffer** → Độ trễ thêm → Tỉ lệ gói đến muộn (late loss) → QoE.

#### D.1.2.1. Mô hình jitter buffer và điều kiện hết lỗi “late”

Giả sử:

- $d_i$: delay một chiều từ sender đến receiver của gói thứ $i$ (unit: giây).  
- Ta mô hình $d_i$ là biến ngẫu nhiên với:

  $$
  d_i = \mu_d + \epsilon_i,
  $$

  trong đó:

  - $\mu_d$: delay trung bình (bao gồm propagation + processing + queueing trung bình);  
  - $\epsilon_i$: thành phần nhiễu (zero-mean jitter) với một phân bố nào đó (Gaussian, heavy-tailed,…).

Ta đặt **playout timestamp** cho gói $i$:

- Gói chứa media timestamp $S_i / f_s$ (giây);  
- Receiver chọn một **playout delay cố định** $D_{\text{pl}}$ (playout buffer size);  
- Thời điểm playout:

  $$
  t_{\text{play},i} = \frac{S_i}{f_s} + D_{\text{pl}}.
  $$

Gói $i$ coi là **hợp lệ** nếu:

$$
R_i^{(\text{s})} \le t_{\text{play},i},
$$

trong đó $R_i^{(\text{s})}$ là arrival time theo giây. Nếu đến muộn:

- $R_i^{(\text{s})} > t_{\text{play},i}$ → gói bị **bỏ** (late loss).

Giả sử nguồn đồng hồ giữa sender–receiver được đồng bộ hoặc sai lệch đã được bù, ta có:

$$
R_i^{(\text{s})} \approx \frac{S_i}{f_s} + d_i.
$$

Điều kiện “không late loss”:

$$
\frac{S_i}{f_s} + d_i \le \frac{S_i}{f_s} + D_{\text{pl}}
\quad \Longleftrightarrow \quad
d_i \le D_{\text{pl}}.
$$

Nếu $d_i$ có phân phối $F_d(x)$, **xác suất late loss**:

$$
P_{\text{late}} = \mathbb{P}(d_i > D_{\text{pl}}) = 1 - F_d(D_{\text{pl}}).
$$

**Trade-off**:

- Tăng $D_{\text{pl}}$ → $P_{\text{late}}$ giảm (ít late loss, ít drop frame do jitter)  
- Nhưng $D_{\text{pl}}$ trực tiếp **tăng độ trễ end-to-end**:

  $$
  T_{\text{E2E}} = T_{\text{cap}} + T_{\text{enc}} + T_{\text{net}} + D_{\text{pl}} + T_{\text{dec}} + T_{\text{rend}}.
  $$

Đây là trade-off cốt lõi:

- Chọn $D_{\text{pl}}$ nhỏ: latency thấp nhưng nhiều gói đến muộn → freeze, glitch.  
- Chọn $D_{\text{pl}}$ lớn: ít mất frame do jitter nhưng latency lớn, làm call/gaming kém tương tác.

#### D.1.2.2. Liên hệ giữa jitter $J$ và kích thước jitter buffer

Nếu ta xấp xỉ jitter $\epsilon_i$ là Gaussian:

- $\epsilon_i \sim \mathcal{N}(0, \sigma_d^2)$;  
- khi đó, delay:

  $$
  d_i = \mu_d + \epsilon_i.
  $$

Chọn $D_{\text{pl}}$ theo “$n$-sigma rule”:

$$
D_{\text{pl}} = \mu_d + n \sigma_d.
$$

Xác suất late loss:

$$
P_{\text{late}} = \mathbb{P}(d_i > D_{\text{pl}})
= \mathbb{P}(\epsilon_i > n \sigma_d)
= Q(n),
$$

trong đó $Q(n)$ là hàm tail Gaussian (ví dụ $Q(2) \approx 0.0228$, $Q(3) \approx 0.00135$).

Nếu $J$ là jitter interarrival đo bởi RFC 3550, trong nhiều trường hợp có thể coi $J \approx c \sigma_d$ với một hệ số gần 1 (tùy model). Như vậy:

- Khi $J$ tăng → $\sigma_d$ tăng → để giữ $P_{\text{late}}$ nhỏ ta phải tăng $D_{\text{pl}}$ → latency tăng.  
- Trong các hệ thống “ultra-low-latency”, có thể chấp nhận $P_{\text{late}}$ lớn hơn để giữ $D_{\text{pl}}$ nhỏ.

#### D.1.2.3. Ảnh hưởng tới QoE video

Trong video thời gian thực (WebRTC, RTP live):

1. **Late loss & freeze**

   - Gói đến muộn bị bỏ, dẫn đến **mất frame** hoặc mất block (tuỳ error concealment).  
   - Nếu nhiều frame liên tiếp bị late loss, người dùng thấy **freeze** (hình dừng vài trăm ms), audio-desync,…

2. **Error propagation do cấu trúc GOP**

   - Với video có GOP, mất gói trong frame loại I hoặc P thường ảnh hưởng **nhiều frame tiếp theo** do prediction chain.  
   - Jitter cao làm tăng xác suất late loss ở “frame quan trọng” (I/P frame), QoE giảm mạnh hơn so với mất B-frame.

3. **Adaptive jitter buffer**

   - Nhiều implementation dùng **adaptive jitter buffer**:

     - đo jitter online (dùng $J_i$ của RTP hoặc thống kê $d_i$),  
     - tăng $D_{\text{pl}}$ khi jitter tăng;  
     - giảm $D_{\text{pl}}$ khi jitter thấp, để giảm latency.

   - Cơ chế này thường có hysteresis để tránh “nhấp nháy” delay.  
   - Từ góc nhìn người dùng:

     - một số thời điểm call “trễ hơn” nhưng ổn định;  
     - nếu jitter buffer điều chỉnh không tốt, có thể xuất hiện các giai đoạn “bất thường” (đột ngột trễ hơn, rồi lại ít trễ).

4. **Kết hợp với congestion control (GCC)**

   - Trong WebRTC, **Google Congestion Control** sử dụng:

     - **trend delay** (độ dốc $d_k$ theo thời gian)  
     - kết hợp với loss để chọn sending rate.

   - Khi jitter (variability của $d_k$) tăng, GCC có thể nhận diện trạng thái “overuse” và **giảm bitrate** $R_k$:

     - Thông qua giảm rate encode hoặc tăng mức compression, giảm framerate → gói nhỏ hơn, bớt queueing.  
     - Điều này giảm jitter về lâu dài, nhưng QoE có thể giảm do chất lượng/độ mượt thấp.

#### D.1.2.4. Tác động trong mô hình QoE tổng quát

Ta xem lại mô hình QoE dạng:

$$\text{QoE} = \sum_{k=1}^{K} u(Q_k) - \alpha_T T_{\text{stall,total}} - \alpha_S \sum_{k=1}^{K-1} |Q_{k+1} - Q_k| - \alpha_L L_{\text{E2E}}.$$

Jitter $J$ ảnh hưởng đến các thành phần:

1. **$T_{\text{stall,total}}$ / freeze**

   - Jitter lớn → nhiều gói đến muộn → tăng late loss;  
   - tuỳ engine, có thể chọn drop frame, kéo giãn thời gian playout,…, tất cả đều làm QoE xấu đi: hoặc giống stall (freeze), hoặc artifacts.

2. **$Q_k$ (chất lượng mỗi segment/frame)**

   - Để giảm jitter, congestion control giảm bitrate, thậm chí giảm framerate → $Q_k$ giảm.  
   - Utility $u(Q_k)$ concave nên việc hạ từ $1080p$ xuống $720p$ gây giảm QoE, nhưng trade-off vẫn lợi hơn so với stall nặng.

3. **$L_{\text{E2E}}$ (latency)**

   - Để che jitter, jitter buffer phải tăng → $L_{\text{E2E}}$ tăng;  
   - Với ứng dụng call, gaming, interactive streaming, **độ nhạy với latency** rất cao, $\alpha_L$ lớn → QoE giảm mạnh.

Trong thiết kế hệ thống:

- Với **VoD/OTT** (DASH/HLS):

  - jitter chủ yếu xuất hiện ở **tải segment** → chuyển thành biến thiên $D_k$ (thời gian tải).  
  - ABR + buffer lớn (tính bằng giây) có thể hấp thụ jitter khá tốt, nên tác động của jitter trên packet-level nhỏ hơn.

- Với **real-time** (RTP/WebRTC):

  - jitter ở mức vài chục ms đã có thể gây cảm nhận rõ rệt;  
  - mọi quyết định về FEC/ARQ, bitrate, jitter buffer đều phải cân nhắc chặt chẽ để tối ưu QoE.

---

### Tài liệu tham khảo cho mục D.1 (định dạng IEEE)

\[D1] H. Schulzrinne, S. Casner, R. Frederick, and V. Jacobson, “RTP: A Transport Protocol for Real-Time Applications,” RFC 3550, IETF, Jul. 2003.  

\[D2] H. Schulzrinne and S. Casner, “RTP Profile for Audio and Video Conferences with Minimal Control,” RFC 3551, IETF, Jul. 2003.  

\[D3] S. Petrangeli, J. Famaey, S. Latré, F. De Turck, “QoE-driven rate adaptation heuristics for HTTP adaptive streaming,” *ACM Trans. Multimedia Comput. Commun. Appl.*, vol. 12, no. 2, pp. 1–29, 2015.  

\[D4] S. Holmer, G. Carlucci, L. De Cicco, and S. Mascolo, “Analysis and design of the Google Congestion Control for Web real-time communication (WebRTC),” *Computer Networks*, vol. 136, pp. 137–151, May 2018.  

\[D5] J. Greengrass, A. Lopez, and M. Brookes, “Quality of experience for VoIP telephony – A survey,” in *Proc. Intl. Workshop on Quality of Multimedia Experience (QoMEX)*, 2009.  

\[D6] ITU-T, “Perceptual evaluation of speech quality (PESQ): An objective method for end-to-end speech quality assessment of narrow-band telephone networks and speech codecs,” Recommendation P.862, 2001.  

\[D7] S. Shenker, C. Partridge, and R. Guerin, “Specification of Guaranteed Quality of Service,” RFC 2212, IETF, Sep. 1997.  

\[D8] M. Handley, S. Floyd, J. Padhye, and J. Widmer, “TCP Friendly Rate Control (TFRC): Protocol Specification,” RFC 5348, IETF, Sep. 2008.
