## C.3. Real-time Video Streaming

Ở phần này, ta tập trung vào các kỹ thuật/ giao thức phục vụ **truyền video thời gian thực (real-time)**, nơi yêu cầu **độ trễ end-to-end thấp** và **jitter nhỏ** quan trọng hơn so với throughput thuần tuý. Ba trụ cột chính:

- **RTP/RTCP** – tầng vận chuyển thời gian thực (VoIP, video conference, WebRTC, IPTV).  
- **WebRTC** – stack giao thức toàn diện cho real-time trong trình duyệt (ICE/STUN/TURN, DTLS-SRTP, GCC).  
- **RTMP** – giao thức lịch sử, nền tảng của Flash, hiện chủ yếu dùng cho ingest.  

Cuối cùng, ta xây dựng **mô hình toán cho độ trễ end-to-end** trong real-time streaming.

---

### C.3.1. RTP/RTCP (RFC 3550)

#### C.3.1.1. Cấu trúc gói RTP

**Real-time Transport Protocol (RTP)** là giao thức tầng ứng dụng dùng để vận chuyển audio/video thời gian thực, thường chạy trên UDP. RTP cung cấp:

- **payload type** (nhận diện codec);  
- **sequence number** (phát hiện mất gói, reorder);  
- **timestamp** (đồng bộ thời gian phát);  
- **SSRC/CSRC** (nhận diện source, hỗ trợ mixer/translator).  

Chuẩn chính: **RFC 3550** – “RTP: A Transport Protocol for Real-Time Applications”.

Cấu trúc header RTP (tối thiểu $12$ byte), mô tả bit-level:

```text
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |V=2|P|X|  CC   |M|     PT      |       sequence number         |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                           timestamp                           |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |           synchronization source (SSRC) identifier            |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |            contributing source (CSRC) identifiers             |
 |                             ....                              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

Giải thích biến:

* $V$ – phiên bản (version), cố định $V = 2$.

* $P$ – padding flag (nếu có padding ở cuối gói).

* $X$ – extension flag (có header mở rộng).

* $CC$ – số CSRC (0–15).

* $M$ – marker bit (ngữ nghĩa phụ thuộc profile, ví dụ đánh dấu frame boundary).

* $PT$ – payload type, chỉ kiểu codec (ví dụ H.264 dynamic PT).

* $sequence\ number$ – số thứ tự, tăng 1 mỗi gói; dùng phát hiện mất gói.

* $timestamp$ – dấu thời gian media:

  * Với audio: $timestamp$ tăng theo **sample clock** (ví dụ $8000$ Hz, $48000$ Hz).
  * Với video: thường tăng theo **frame clock** hoặc **90 kHz clock** chuẩn RTP.

* $SSRC$ – Synchronization Source ID, duy nhất trong 1 session RTP.

* $CSRC$ – danh sách contributing source khi sử dụng mixer.

Nếu ta ký hiệu:

* $f_s$ – tần số clock timestamp (Hz), ví dụ $f_s = 90000$ cho video;
* $T_{\text{frame}}$ – thời gian một frame (s), ví dụ $T_{\text{frame}} = 1/30$;
* frame thứ $n$ được đánh timestamp:

  $$
  S_n = S_0 + n \cdot T_{\text{frame}} \cdot f_s
  $$

trong đó $S_n$ là timestamp RTP của frame thứ $n$, $S_0$ là offset ban đầu.

Header RTP **không chứa** địa chỉ IP/port – việc routing do IP/UDP đảm nhiệm.

---

#### C.3.1.2. RTCP report, thống kê jitter và loss

**RTP Control Protocol (RTCP)** đi kèm với RTP để:

* đo lường chất lượng truyền (loss, jitter, delay);
* phân phối thông tin đồng bộ (NTP vs RTP timestamp);
* cung cấp meta (SDES: CNAME, NAME,…).

Các loại packet chính:

* **SR (Sender Report)** – từ sender, chứa thống kê gửi: số gói, byte, mapping giữa NTP time và RTP timestamp.
* **RR (Receiver Report)** – từ receiver, chứa thống kê nhận: fraction lost, cumulative loss, jitter, LSR/DLSR (cho round-trip delay).

Ký hiệu cho source $s$:

* $N_{\text{sent}}$ – tổng số gói RTP đã gửi.
* $N_{\text{recv}}$ – tổng số gói RTP đã nhận.
* $N_{\text{exp}}$ – tổng số gói **expected** (từ sequence number).

**Fraction lost** (trong RR):

$$
f_{\text{lost}}
= \frac{N_{\text{exp}} - N_{\text{recv}}}{N_{\text{exp}}}
$$

**Cumulative loss**:

$$
N_{\text{lost,cum}} = N_{\text{exp}} - N_{\text{recv}}
$$

Hai metric này cho phép đo tỷ lệ mất gói tức thời và tích lũy.

##### Jitter inter-arrival trong RTP

RFC 3550 định nghĩa **inter-arrival jitter** dựa trên sai khác giữa **timestamp RTP** và **thời gian đến thực tế**.

Ký hiệu:

* $S_i$ – timestamp RTP của gói thứ $i$ (đơn vị clock RTP).
* $R_i$ – thời gian đến (arrival time) của gói thứ $i$ tính theo **cùng đơn vị** với timestamp (thường $R_i = t_i \cdot f_s$).
* $D(i,j)$ – sai khác **relative transit time** cho hai gói $i$ và $j$.

Định nghĩa:

$$
D(i,j)
= (R_j - R_i) - (S_j - S_i)
= (R_j - S_j) - (R_i - S_i)
$$

**Jitter inter-arrival** $J(i)$ được cập nhật đệ quy mỗi khi nhận gói mới $i$:

* Với $D_i = D(i-1,i)$, ta có:

  $$
  J(i) = J(i-1) + \frac{|D_i| - J(i-1)}{16}
  $$

Trong đó:

* $J(i)$ – ước lượng jitter tại gói thứ $i$ (đơn vị clock RTP);
* hệ số $1/16$ tạo ra **bộ lọc trung bình trượt hàm mũ** (EMA) với “quán tính” cao → jitter ổn định, bớt nhiễu.

Nếu **clock RTP** có tần số $f_s$, jitter tính theo giây:

$$
J_{\text{sec}}(i) = \frac{J(i)}{f_s}
$$

Ví dụ với video: $f_s = 90000$, $J(i) = 900$ → $J_{\text{sec}} = 0.01$ s = $10$ ms.

Metric jitter và loss trong RTCP RR được dùng để:

* điều chỉnh **jitter buffer** ở receiver;
* “feed” vào **congestion control** (ví dụ WebRTC GCC sử dụng cả delay/loss);
* giám sát QoS, trigger adaptation (giảm bitrate, giảm framerate…).

---

### C.3.2. WebRTC

WebRTC là **bộ giao thức** cho truyền thông thời gian thực trong trình duyệt, được chuẩn hóa bởi IETF/ W3C. Kiến trúc tổng thể được mô tả trong **RFC 8825 – Overview: Real-Time Protocols for Browser-Based Applications** và **RFC 8835 – Transports for WebRTC**.

Stack WebRTC cho media:

```text
+------------------------------+
|      Application / JS        |
+------------------------------+
|   WebRTC API (RTCPeerConn.)  |
+------------------------------+
|   RTP/RTCP  +  SRTP (media)  |
|   SCTP/DTLS (data channel)   |
+------------------------------+
|  ICE (STUN/TURN, candidate)  |
+------------------------------+
| UDP / (TCP fallback) / IP    |
+------------------------------+
```

Các thành phần cốt lõi:

* **ICE / STUN / TURN** – NAT traversal.
* **SRTP, DTLS-SRTP** – bảo mật media.
* **Congestion Control (GCC)** – điều khiển tắc nghẽn thời gian thực.

---

#### C.3.2.1. Kiến trúc ICE / STUN / TURN

**Interactive Connectivity Establishment (ICE)** (RFC 8445) là cơ chế tìm đường đi tối ưu (trực tiếp nếu có thể) giữa hai endpoint qua NAT/firewall, sử dụng **STUN** và **TURN**.

Ký hiệu:

* $N_{\text{L}}$ – số lượng **local candidates** (host, server-reflexive qua STUN, relayed TURN) của phía local.
* $N_{\text{R}}$ – số lượng **remote candidates**.
* Số cặp candidate cần thử (connectivity checks):

  $$
  N_{\text{pair}} \le N_{\text{L}} \cdot N_{\text{R}}
  $$

Quy trình ICE:

1. **Gathering** – mỗi endpoint thu thập candidates:

   * Host candidate (địa chỉ local).
   * Server-reflexive (qua STUN: hỏi STUN server để biết public IP/port).
   * Relayed (qua TURN: endpoint xin một địa chỉ relay trên TURN server).

2. **Exchange** – hai bên trao đổi danh sách candidates qua signaling (ví dụ SIP, WebSocket, HTTP,…).

3. **Connectivity checks** – sử dụng STUN Binding Request qua UDP để kiểm tra xem một cặp candidate $(c_{\text{L}}, c_{\text{R}})$ có kết nối được hay không.

4. **Nomination** – chọn một cặp tốt nhất (ưu tiên direct path STUN, fallback TURN khi cần).

Độ phức tạp search path của ICE **tối đa** là $O(N_{\text{L}} N_{\text{R}})$, nhưng chuẩn định nghĩa **lịch ưu tiên** để giảm số cặp phải thử.

**STUN** (RFC 5389):

* Cho phép endpoint phát hiện IP/port phía public NAT mapping và giữ NAT binding sống (keep-alive).

**TURN** (RFC 8656):

* Cung cấp relay trung gian khi direct path không khả thi (symmetry NAT).
* Đổi lại, mọi media đều đi qua TURN → tăng $T_{\text{net}}$ và tải server.

Ta có thể mô hình hóa **probability có direct path** là $p_{\text{direct}}$ (phụ thuộc phân bố loại NAT). Khi $p_{\text{direct}}$ nhỏ, tỉ lệ session phải dùng TURN (và chi phí băng thông cho provider) sẽ tăng lên tương ứng.

---

#### C.3.2.2. SRTP, DTLS-SRTP cho bảo mật

**Secure Real-time Transport Protocol (SRTP)** (RFC 3711) là một *profile* của RTP cung cấp:

* mã hóa (confidentiality);
* xác thực/ integrity (message authentication, replay protection);
* áp dụng cho cả RTP và RTCP (SRTCP).

Ký hiệu:

* $K$ – khóa mã hóa SRTP (session key).
* $SSRC$ – định danh nguồn RTP.
* $ROC$ (roll-over counter) – đếm số lần sequence number vòng lại.
* $S$ – sequence number 16 bit.

SRTP build **index gói**:

$$
\text{index} = (\text{ROC} \ll 16) + S
$$

Index này dùng:

* tạo **nonce** cho AEAD cipher (AES-CTR, AES-GCM, ChaCha20-Poly1305);
* tạo keystream, MAC, đảm bảo mỗi gói có IV khác nhau.

Trong WebRTC, việc trao đổi khóa $K$ được thực hiện qua **DTLS-SRTP** (RFC 5764):

* Hai endpoint thiết lập một phiên **DTLS** trên cùng UDP socket;
* DTLS handshake sinh ra các master secret;
* Từ đó dẫn xuất các SRTP key (client/server write key & salt).

Khi handshake xong:

* Media đi trực tiếp bằng **SRTP trên UDP**;
* DTLS chỉ dùng cho signaling bảo mật của SRTP (không phải mã hóa toàn bộ media nữa).

WebRTC bắt buộc **end-to-end SRTP** giữa peer (trừ khi có media gateway), kết hợp với **ICE** (NAT traversal) và **DTLS-SRTP** (key management) để hình thành một kiến trúc bảo mật hoàn chỉnh.

---

#### C.3.2.3. Congestion Control GCC (Google Congestion Control)

Trong môi trường thời gian thực, không thể dùng **TCP congestion control** do:

* head-of-line blocking;
* delay không chấp nhận được khi retransmission.

WebRTC sử dụng **Google Congestion Control (GCC)** – một thuật toán điều khiển tắc nghẽn trên UDP/RTP, dựa trên:

* **delay-based estimator** – đo gradient trễ;
* **loss-based component** – dựa trên tỷ lệ mất gói;
* **AIMD (Additive-Increase/Multiplicative-Decrease)** hoặc biến thể.

##### a) Mô hình độ trễ

Ký hiệu:

* $d_k$ – độ trễ một chiều (hoặc delay proxy từ arrival time) đo được cho gói/cluster thứ $k$;
* $\bar{d}_k$ – giá trị trung bình/low-pass filtered;
* $g_k = d_k - \bar{d}_k$ – delay gradient (độ lệch so với trung bình).

Bộ lọc trung bình trượt:

$$
\bar{d}*k = (1 - \alpha) \bar{d}*{k-1} + \alpha d_k,\quad 0 < \alpha < 1
$$

* Nếu $g_k$ dương và tăng dần → queue đang **tích tụ** → có dấu hiệu congestion.
* Nếu $g_k$ nhỏ hoặc âm → queue ổn định/giảm → có thể tăng bitrate.

Estimator thực tế dùng **Kalman filter** hoặc **linear regression** trên nhiều điểm $(t_k, d_k)$ để ước lượng **trendline** (góc dốc của delay theo thời gian). Khi slope vượt một ngưỡng $\theta_{\text{over}}$ → trạng thái “overuse”; khi dưới ngưỡng $\theta_{\text{under}}$ → “underuse”.

##### b) Cập nhật bitrate mục tiêu

Ký hiệu:

* $x_k$ – ước lượng **băng thông mục tiêu** (bitrate allowed) tại decision $k$;
* $s_k$ – trạng thái: underuse, normal, overuse.

Quy tắc:

* Nếu $s_k = \text{underuse}$:

  * tăng dần tuyến tính:

    $$
    x_{k+1} = x_k + \Delta_{\text{up}}
    $$

* Nếu $s_k = \text{overuse}$:

  * giảm nhân đôi (multiplicative decrease):

    $$
    x_{k+1} = \beta x_k,\quad 0 < \beta < 1
    $$

* Nếu $s_k = \text{normal}$: giữ nguyên hoặc tăng nhẹ.

Đồng thời, GCC sử dụng **loss fraction** $p_k$ từ RTP/RTCP:

* nếu $p_k$ cao dù delay không tăng → giảm bitrate vì mạng đang drop do queue đầy;
* nếu $p_k$ thấp và delay ổn → tăng bitrate.

Ở phía sender:

* bitrate mã hóa video $R_k$ được chọn sao cho $R_k \le x_k$;
* kết hợp với **FEC**, **PLI/NACK** để xử lý loss ở mức ứng dụng.

GCC đã được triển khai trong Chrome, Firefox, các stack WebRTC server/client, và là một trong các candidate chính cho chuẩn RMCAT của IETF.

---

### C.3.3. RTMP

**Real-Time Messaging Protocol (RTMP)** là giao thức tầng ứng dụng do Macromedia (sau này là Adobe) thiết kế, sử dụng chủ yếu giữa:

* **Flash Player** ⟷ **Flash Media Server / Adobe Media Server**;
* và hiện tại chủ yếu dùng làm **ingest** từ encoder (OBS, vMix…) đến media server.

RTMP chạy trên **TCP** (mặc định port $1935$), duy trì **kết nối persistent** để:

* multiplex nhiều stream (audio/video/data) trên cùng connection;
* truyền **chunk** với độ dài nhỏ (ví dụ 128–4096 bytes);
* hỗ trợ control message (connect, play, pause, seek, publish,…).

#### C.3.3.1. Nguyên lý hoạt động

Pipeline RTMP điển hình cho live:

```text
+----------+       TCP/RTMP        +-----------------+       HLS/DASH
| Encoder  | --------------------> | Media Server    | --->  Viewers
| (OBS...) |                       | (Wowza, Nginx...)|
+----------+                       +-----------------+
```

* **Encoder**:

  * mã hóa video (H.264/HEVC) + audio (AAC/Opus);
  * đóng gói vào RTMP messages (data, video, audio);
  * fragment thành **chunk** fixed-size, gửi tuần tự trên TCP.

* **Media Server**:

  * nhận RTMP stream;
  * có thể:

    * relay RTMP (push/pull);
    * transcode;
    * hoặc **repack** sang HLS/DASH (segment TS/fMP4).

Cấu trúc logic:

* **Chunk stream**: mỗi media stream được chia thành nhiều “chunk stream” với chunk header chứa:

  * stream ID;
  * timestamp delta;
  * message length;
  * type ID (video/audio/data).

* **AMF commands**: control message encode bằng AMF0/AMF3 (connect, play, publish, pause,…).

#### C.3.3.2. Hạn chế so với các giải pháp mới

1. **Dựa trên TCP** → chịu **head-of-line blocking**:

   * Khi một segment bị mất, TCP sẽ **dừng** gửi dữ liệu mới cho đến khi retransmission xong;
   * Điều này làm **tăng độ trễ** và jitter không kiểm soát được;
   * Không phù hợp với **tương tác ultra-low-latency** (calls, gaming, bidding).

2. **Phụ thuộc Flash** (lịch sử):

   * RTMP ban đầu dùng với Flash Player;
   * Flash đã bị khai tử (EOL) → RTMP không còn là lựa chọn playback trong browser;
   * Hiện RTMP chủ yếu dùng ở **ingest side** (encoder → server), còn viewer dùng HLS/DASH/WebRTC.

3. **Không chuẩn IETF/ISO**:

   * RTMP là đặc tả của Adobe (sau này mở tài liệu nhưng không thành Internet Standard);
   * Không được tích hợp sâu trong stack WebRTC hoặc các chuẩn mới.

4. **Latency hiện thực**:

   * Do TCP + server-side buffer, latency RTMP đến viewer thường **vài giây** (3–5 s hoặc hơn);
   * Độ trễ khó push xuống mức sub-second như WebRTC hoặc LL-HLS/CMAF.

Tuy vậy, RTMP vẫn được sử dụng rộng rãi trong thực tế như **giao thức ingest**:

* Encoder → RTMP → Media server → transcode → HLS/DASH/WebRTC;
* Lý do: tài liệu thư viện, toolchain RTMP rất phong phú, hỗ trợ tốt trong encoder (OBS, XSplit,…).

---

### C.3.4. Mô hình độ trễ end-to-end trong real-time streaming

Độ trễ end-to-end **glass-to-glass** $T_{\text{E2E}}$ là tổng thời gian từ khi ánh sáng chạm vào camera đến khi frame tương ứng xuất hiện trên màn hình người xem.

Ta phân tách:

* $T_{\text{cap}}$ – độ trễ do **capture** (bao gồm thời gian quét khung hình, rolling shutter).
* $T_{\text{enc}}$ – độ trễ do **encoder** (buffer frame, lookahead, Group-of-Picture).
* $T_{\text{pkt}}$ – độ trễ do **packetization/framing** (RTPization hoặc chunking RTMP/CMAF).
* $T_{\text{net}}$ – độ trễ mạng một chiều (propagation + queueing).
* $T_{\text{jitt}}$ – độ trễ do **jitter buffer** ở receiver.
* $T_{\text{dec}}$ – độ trễ decode (HW/SW decoder pipeline).
* $T_{\text{rend}}$ – độ trễ render/display (double buffering, vsync).

Mô hình:

$$
T_{E2E}
= T_{cap} + T_{enc} + T_{pkt} + T_{net} + T_{jitt} + T_{dec} + T_{rend}
$$

Trong đó:

* $T_{\text{cap}} \approx \frac{1}{2 f_{\text{fps}}}$ nếu frame được sample “đều” trong chu kỳ (trung bình).

* $T_{\text{enc}}$ phụ thuộc:

  * độ dài GOP (B-frame nhiều → nhiều delay);
  * lookahead;
  * chế độ low-delay vs high-efficiency.

* $T_{\text{pkt}}$:

  * Với RTP: grouping NALU vào packet, pacing;
  * Với CMAF/LL-HLS: chunk duration $T_{\text{chunk}}$;
  * Với RTMP: chunk size + buffering server.

* $T_{\text{net}}$:

  * có phân bố $d \sim \mathcal{D}$ với mean $\mu_d$, variance $\sigma_d^2$;
  * jitter là $\sigma_d$ và các outlier (tail).

* $T_{\text{jitt}}$:

  * jitter buffer phải đủ lớn để hấp thụ dao động delay mạng, thường:

    $$
    T_{\text{jitt}}
    \gtrsim \mu_d + n \sigma_d
    $$

    với $n$ từ $1$ đến $3$ tùy mức chấp nhận loss vs delay.

  * Nếu $T_{\text{jitt}}$ quá nhỏ → cao nguy cơ underflow (stall/freeze);

  * Nếu $T_{\text{jitt}}$ quá lớn → tăng $T_{\text{E2E}}$.

**Trade-off cơ bản**:

* Muốn $T_{\text{E2E}}$ rất nhỏ ($\le 200$–$300$ ms cho calls, gaming):

  * cần:

    * $T_{\text{enc}}$ cực thấp (low-delay preset, gần như không B-frame);
    * dùng **RTP/WebRTC** với GCC, không dựa vào TCP/RTMP;
    * jitter buffer nhỏ, chấp nhận **mất frame nhẹ** khi mạng xấu;
    * $T_{\text{chunk}}$ (nếu có) phải rất nhỏ (sub-second, thậm chí sub-200 ms với CMAF chunk).

* Với **live OTT** (streaming sự kiện, latency 2–6 s chấp nhận được):

  * có thể dùng LL-HLS/LL-DASH với CMAF;
  * $T_{\text{chunk}} \approx 200$–500 ms, $T_{\text{jitt}}$ 1–2 s;
  * ưu tiên **stability + chất lượng** hơn là absolute low latency.

Ta cũng có thể tách **thành phần do network**:

$$
T_{\text{net+buff}} = T_{\text{net}} + T_{\text{jitt}}
$$

Giả sử:

* mạng có jitter $\sigma_d$ tăng khi load cao;
* để giữ $T_{\text{E2E}}$ dưới ngưỡng $T_{\text{target}}$, GCC và ABR phải:

  * giảm bitrate $R_k$ khi $d_k$ tăng (queue build-up);
  * điều chỉnh lại $T_{\text{jitt}}$ (adaptive jitter buffer);
  * trong extreme case, hạ resolution/framerate hoặc drop frame.

Như vậy, các kỹ thuật ở mục này (RTP/RTCP, ICE/DTLS-SRTP, GCC, RTMP) có thể được nhìn dưới lăng kính **một hệ thống điều khiển** trong đó $T_{\text{E2E}}$ là output cần khống chế dưới một ngưỡng, với các biến điều khiển:

* bitrate $R_k$;
* pacing rate;
* kích thước buffer $T_{\text{jitt}}$;
* lựa chọn đường đi (ICE: direct vs TURN).

---

### Tài liệu tham khảo cho mục C.3 (định dạng IEEE)

[C24] H. Schulzrinne, S. Casner, R. Frederick, and V. Jacobson, “RTP: A Transport Protocol for Real-Time Applications,” RFC 3550, IETF, Jul. 2003.

[C25] H. Schulzrinne and S. Casner, “RTP Profile for Audio and Video Conferences with Minimal Control,” RFC 3551, IETF, Jul. 2003.

[C26] M. Baugher, D. McGrew, M. Naslund, E. Carrara, and K. Norrman, “The Secure Real-time Transport Protocol (SRTP),” RFC 3711, IETF, Mar. 2004.

[C27] E. Rescorla, “Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP),” RFC 5764, IETF, May 2010.

[C28] H. Alvestrand, “Overview: Real-Time Protocols for Browser-Based Applications,” RFC 8825, IETF, Jan. 2021.

[C29] H. Alvestrand, “Transports for WebRTC,” RFC 8835, IETF, Jan. 2021.

[C30] E. Rescorla, “WebRTC Security Architecture,” RFC 8827, IETF, Jan. 2021.

[C31] J. Rosenberg, “Interactive Connectivity Establishment (ICE): A Protocol for NAT Traversal,” RFC 8445, IETF, Jul. 2018.

[C32] J. Rosenberg, R. Mahy, P. Matthews, and D. Wing, “Session Traversal Utilities for NAT (STUN),” RFC 5389, IETF, Oct. 2008.

[C33] J. Rosenberg, A. Keränen, A. Johnston, and R. even, “Traversal Using Relays around NAT (TURN): Relay Extensions to STUN,” RFC 8656, IETF, Oct. 2019.

[C34] S. Holmer, G. Carlucci, L. De Cicco, and S. Mascolo, “Analysis and design of the Google Congestion Control for Web real-time communication (WebRTC),” *Computer Networks*, vol. 136, pp. 137–151, May 2018.

[C35] S. Islam, D. Pan, and H. Schulzrinne, “Performance Evaluation of WebRTC-based Video Conferencing,” Columbia Univ. Tech. Rep., 2016.

[C36] S. Petrangeli, J. Famaey, S. Latré, R. Huysegems, and F. De Turck, “A Lightweight HTTP Adaptive Streaming Client for WebRTC,” in *Proc. IEEE ICC*, 2016.

[C37] Adobe Systems Inc., “Adobe’s Real Time Messaging Protocol (RTMP) Specification,” Adobe Developer Connection, Dec. 2012.

[C38] “Real-Time Messaging Protocol (RTMP),” Wikipedia, 2025, accessed Nov. 2025.

[C39] “Video latency: Understanding streaming delays,” Nanocosmos Tech Blog, 2025.

[C40] B. Shi and L. Zhang, “Event Sequence-Driven Generalized and Accurate End-to-End Streaming Latency Measurement,” in *Proc. Intl. Conf. on Machine Learning and Intelligent Communications (MLICOM)*, Springer, 2024.

