## C.2. Adaptive Bitrate Streaming (ABR)

Adaptive Bitrate Streaming (ABR) là kỹ thuật mà **cùng một nội dung video** được **mã hóa ở nhiều bitrate khác nhau**, được cắt thành các **segment ngắn** (vài giây), và client **chủ động chọn** bitrate của từng segment dựa trên:

- ước lượng throughput mạng hiện tại $ \hat{C}_k $,
- mức buffer $ B_k $,
- và mục tiêu QoE (chất lượng, stall, độ mượt).

ABR hiện là cơ chế nền tảng của MPEG-DASH, HLS, Smooth Streaming,… và là **de facto standard** cho streaming trên Internet \[C8], \[C9], \[C14].

---

### C.2.1. Kiến trúc chung của ABR trên HTTP

#### C.2.1.1. Khái niệm segment, representation, profile

Trong ABR, mỗi video được chuyển hóa thành:

- Tập các **representation**: mỗi representation là một phiên bản video với:
  - bitrate danh nghĩa $ R^{(m)} $ (bit/s),
  - độ phân giải $ (W^{(m)}, H^{(m)}) $,
  - codec/profile (H.264/AVC, HEVC, AV1…).

Ký hiệu:

- Tập bitrate khả dụng:  
  $$
  \mathcal{R} = \{ R^{(1)}, R^{(2)}, \dots, R^{(M)} \}, \quad
  R^{(1)} < R^{(2)} < \dots < R^{(M)}.
  $$

- Video được chia thành các **segment** có độ dài gần như cố định $ T_{\text{seg}} $ (giây).  
  Segment thứ $k$ của representation $m$ có:
  - thời lượng xấp xỉ $ T_{\text{seg}} $,
  - kích thước $ S_k^{(m)} \approx R^{(m)} T_{\text{seg}} $ (bit).

Với HTTP adaptive streaming:

- Mỗi segment là **một object HTTP** (file `.m4s`, `.ts`, `.cmf`…), được cache bình thường trên CDN;
- Client không cần server “stream” theo thời gian thực, mà chỉ cần gửi các HTTP GET tới URL của segment.

#### C.2.1.2. Manifest: MPD (DASH) và Playlist M3U8 (HLS)

ABR dựa trên **manifest** – một file mô tả:

- danh sách representation, bitrate, resolution, codec;
- danh sách hoặc pattern URL của từng segment;
- cấu trúc thời gian (timeline) của presentation.

Hai dạng manifest phổ biến:

- **MPD – Media Presentation Description (XML)** trong MPEG-DASH \[C8];  
- **M3U8 playlist (text)** trong HLS \[C9].

Quy trình tổng quát:

1. Client tải manifest (MPD/M3U8).  
2. Dựa trên manifest, client biết tập $ \mathcal{R} $ và URL segment.  
3. Mỗi lần cần segment $k$, client:
   - dùng thuật toán ABR để chọn bitrate index $m_k$ tương ứng với $R^{(m_k)}$,
   - gửi HTTP GET tới segment tương ứng (ví dụ `seg_$k$_$m_k$.m4s`).  
4. Sau khi tải xong, client:
   - cập nhật buffer $B_k$,
   - dùng thông tin thời gian tải, kích thước để cập nhật ước lượng throughput $ \hat{C}_k $.

Một vòng lặp “ABR loop” đơn giản:

```text
while (chưa hết video):
    đo throughput C_k từ segment vừa tải
    cập nhật ước lượng \hat{C}_k
    đọc buffer B_k hiện tại
    chọn bitrate R^{(m_{k+1})} = f_{\text{ABR}}(\hat{C}_k, B_k, \text{QoE params})
    tải segment tiếp theo với bitrate R^{(m_{k+1})}
    cập nhật buffer B_{k+1}
```

Trong đó $ f_{\text{ABR}}(\cdot) $ là logic thuật toán ABR (rate-based, buffer-based, hybrid…).

---

### C.2.2. MPEG-DASH

#### C.2.2.1. Cấu trúc MPD

MPD (Media Presentation Description) là một tài liệu XML, chuẩn hóa trong ISO/IEC 23009-1 [C8], mô tả:

* tổng thời lượng presentation;
* các **Period**: các đoạn logic (chapter, quảng cáo, program);
* trong mỗi Period: các **AdaptationSet** cho video, audio, subtitle;
* trong mỗi AdaptationSet: nhiều **Representation** với bitrate/resolution khác nhau;
* cách truy cập segment (SegmentTemplate, SegmentList, SegmentTimeline…).

Ký hiệu:

* Period thứ $i$: $P_i$, có thời lượng $ T_{P_i} $.
* AdaptationSet $j$ trong Period $i$: $A_{i,j}$.
* Representation thứ $m$ trong $A_{i,j}$: $R_{i,j,m}$.

Tổng thời lượng:

$$
T_{\text{MPD}} = \sum_i T_{P_i}.
$$

Mỗi $R_{i,j,m}$ chứa:

* bitrate danh nghĩa $ R_{i,j,m}^{\text{nom}} $,
* codec (ví dụ AVC/HEVC/AV1),
* resolution, framerate,
* metadata về segment (URL pattern, duration, timeline).

#### C.2.2.2. AdaptationSet, Representation, SegmentTemplate

**AdaptationSet** nhóm các track “thay thế lẫn nhau” (mutually exclusive) – ví dụ 1 AdaptationSet video, 1 audio, 1 subtitle.
Trong AdaptationSet video:

* Các **Representation** là các phiên bản cùng nội dung nhưng khác bitrate/resolution.

Gọi:

* $M$ là số representation trong một AdaptationSet video;
* $R^{(m)}$ là bitrate của representation thứ $m$, $m = 1,\dots,M$.

**SegmentTemplate** cung cấp mẫu URL cho segment, ví dụ:

```xml
<SegmentTemplate
    media="video_$Number$.m4s"
    initialization="video_init.mp4"
    timescale="1"
    duration="4"/>
```

* $T_{\text{seg}} = \frac{\text{duration}}{\text{timescale}} = 4$ s;
* segment index $k$ → URL `video_k.m4s`;
* initialization segment `video_init.mp4` chứa `ftyp`, `moov`/`sidx` cần cho giải mã.

Với SegmentTimeline, thời lượng từng segment có thể biến thiên:

* mỗi phần tử `S` có `t` (start time), `d` (duration), `r` (repeat count);
* mapping giữa index $k$ và thời gian $t_k$ được xác định bởi cumulative sum các `d$`.

#### C.2.2.3. DASH live và low-latency DASH

Trong **DASH live**, MPD được cập nhật liên tục:

* với mỗi “live edge” tại thời điểm $t$, chỉ một cửa sổ segment gần $t$ được liệt kê;
* client dùng `availabilityStartTime`, `minimumUpdatePeriod`, `timeShiftBufferDepth`… để xác định segment nào có sẵn [C8].

Đối với **Low-Latency DASH (LL-DASH)**, DASH-IF đề xuất:

* sử dụng **CMAF chunks** (xem C.2.4),
* HTTP chunked transfer / HTTP/2,
* signal trong MPD các thông tin về **chunk duration**, **low-latency mode** [C10], [C13].

Tổng thể, MPD cung cấp tất cả thông tin cấu trúc; thuật toán ABR chỉ cần đọc MPD và các thông tin download để ra quyết định.

---

### C.2.3. HLS và Low-Latency HLS

#### C.2.3.1. Playlist M3U8 và segment TS/fMP4

Trong HLS [C9], manifest là các file **M3U8**:

* **Multivariant playlist** (master playlist):

  * liệt kê nhiều **variant stream**, mỗi variant có `BANDWIDTH`, `RESOLUTION`, `CODECS`,…
  * mỗi variant trỏ tới một **media playlist**.

* **Media playlist**:

  * liệt kê các segment của một variant,
  * dùng thẻ `#EXTINF` cho duration,
  * `#EXT-X-TARGETDURATION` xác định upper bound duration segment.

Ví dụ đơn giản master playlist:

```m3u8
#EXTM3U
#EXT-X-STREAM-INF:BANDWIDTH=800000,RESOLUTION=640x360
low/index.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=1600000,RESOLUTION=1280x720
mid/index.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=3200000,RESOLUTION=1920x1080
high/index.m3u8
```

Client ABR:

* dựa vào ước lượng throughput $ \hat{C}_k $ và buffer $B_k$ để chọn variant có bitrate $R^{(m_k)}$ phù hợp;
* rồi tải `index.m3u8` của variant đó, sau đó tải từng segment `.ts` hoặc `.m4s`.

Ban đầu HLS sử dụng **MPEG-2 TS (.ts)** làm container segment; sau này hỗ trợ **fMP4** (fragmented MP4) cho phép tương thích với CMAF [C11].

#### C.2.3.2. Low-Latency HLS: partial segments, preload hints

Apple mở rộng HLS thành **Low-Latency HLS (LL-HLS)** để giảm độ trễ xuống cỡ 1–3 s [C11]:

* **Partial segments** (`#EXT-X-PART`):

  * segment logic độ dài $T_{\text{seg}}$ được chia thành $n$ partial, mỗi partial dài $T_{\text{part}} = \frac{T_{\text{seg}}}{n}$, thường vài trăm ms;
  * partial có thể được push/gửi dần qua HTTP chunked transfer.

* **Preload hints** (`#EXT-X-PRELOAD-HINT`):

  * cho phép client **yêu cầu trước** partial/segment sắp tới, giảm round-trip overhead.

* **Blocking playlist reload**:

  * client gửi GET playlist với tham số directive (ví dụ `_HLS_msn=...`) để yêu cầu server *block* đến khi playlist có thêm partial mới → tránh polling dày đặc.

Mô hình đơn giản:

* Thay vì chờ tải xong cả segment $T_{\text{seg}}$ mới phát, client có thể:

  * nhận partial đầu tiên (ví dụ $T_{\text{part}} = 0.5$ s),
  * nếu buffer đủ, bắt đầu phát ngay,
  * tiếp tục nhận partial tiếp theo song song.

Như vậy $T_{\text{client-buf}}$ và $T_{\text{E2E}}$ được giảm trong khi vẫn giữ mô hình HLS/HTTP.

---

### C.2.4. CMAF và Low-Latency Streaming

**Common Media Application Format (CMAF)** (ISO/IEC 23000-19) định nghĩa một định dạng chứa segmented media tối ưu cho adaptive streaming [C12]:

* dựa trên **ISO Base Media File Format (ISOBMFF)**;
* định nghĩa **CMAF Track**, **CMAF Fragment**, **CMAF Chunk**;
* đảm bảo các fragment ở các bitrate khác nhau **align theo thời gian**, cho phép seamless switching.

Các khái niệm chính:

* **CMAF Fragment**:

  * đơn vị tương ứng với một segment logic (ví dụ $T_{\text{frag}} = T_{\text{seg}}$);
  * chứa một hoặc nhiều `moof` + `mdat`.

* **CMAF Chunk**:

  * chia nhỏ fragment thành nhiều khối nhỏ hơn (thường vài trăm ms),
  * được gửi bằng HTTP chunked transfer để hỗ trợ low-latency.

Gọi:

* $T_{\text{frag}}$: độ dài fragment;
* $n$: số chunk trong fragment;
* $T_{\text{chunk}} = \frac{T_{\text{frag}}}{n}$.

Với **Low-Latency DASH** và **LL-HLS** dựa trên CMAF:

* cả hai giao thức dùng **chung** các CMAF fragment/chunk (file `.m4s`);
* DASH MPD và HLS playlist chỉ khác ở **manifest**/signaling, còn dữ liệu media là như nhau [C12], [C13], [C15].

Điều này giúp:

* giảm ~50% số object cần lưu trữ (không cần TS riêng cho HLS) như đã phân tích ở B.5;
* tối ưu cache trên CDN;
* đơn giản hóa pipeline encode/packaging.

Về mặt ABR, sử dụng CMAF không thay đổi bản chất thuật toán $ f_{\text{ABR}} $, nhưng:

* cho phép **granularity thời gian nhỏ** (chunk-level) → ABR có thể quyết định sớm và phản ứng nhanh với biến động mạng;
* hỗ trợ tốt cho các kịch bản **ultra-low-latency** (live auction, cloud gaming, interactive video).

---

### C.2.5. Mô hình toán học cho ABR

Ta xây dựng mô hình rời rạc theo segment để làm nền cho phân tích và thiết kế thuật toán ABR [C16], [C17].

#### C.2.5.1. Mô hình buffer dynamics

Ký hiệu:

* $k$: chỉ số decision/segment ($k = 1,2,\dots$);
* $T_{\text{seg}}$: độ dài segment (s);
* $R^{(m)}$: bitrate của representation thứ $m$ trong tập $\mathcal{R}$;
* $m_k$: index bitrate được chọn tại decision $k$;
* $R_k = R^{(m_k)}$: bitrate thực dùng cho segment $k$;
* $S_k = R_k T_{\text{seg}}$: kích thước segment $k$ (bit, xấp xỉ);
* $C_k$: throughput thực đo được khi tải segment $k$ (bit/s);
* $D_k = \frac{S_k}{C_k}$: thời gian tải segment $k$ (s);
* $B_k$: mức buffer (giây video) **ngay trước** khi bắt đầu tải segment $k$.

Giả sử playback đang chạy (không ở trạng thái stall) tại đầu khoảng tải segment $k$, thì:

* Trong thời gian $D_k$, buffer bị tiêu hao $D_k$ giây do playback.
* Khi segment tải xong, buffer cộng thêm $T_{\text{seg}}$ giây mới.

Ta có quan hệ:

$$B_{k+1} = \max\{0,\ B_k - D_k\} + T_{\text{seg}}.$$

Nếu $B_k > D_k$:

* không stall trong khoảng tải segment $k$;
* $B_{k+1} = B_k - D_k + T_{\text{seg}}$.

Nếu $B_k \le D_k$:

* buffer chạm 0 trước khi tải xong → xảy ra stall;

* thời gian stall:

  $$
  T_{\text{stall},k} = D_k - B_k;
  $$

* sau khi tải xong, buffer:

  $$
  B_{k+1} = T_{\text{seg}}.
  $$

Tổng thời gian stall:

$$
T_{\text{stall,total}} = \sum_k T_{\text{stall},k}.
$$

Đây là mô hình **chuẩn** được nhiều công trình ABR sử dụng [C16], [C17].

#### C.2.5.2. Ước lượng băng thông (throughput estimation)

Trong decision $k$, client dùng các mẫu $C_i$ đã đo để ước lượng băng thông tương lai:

* Với EMA (Exponential Moving Average):

  $$
  \hat{C}*k = (1 - \alpha)\hat{C}*{k-1} + \alpha C_k,\quad 0 < \alpha \le 1.
  $$

* Hoặc harmonic mean trên $n$ segment gần nhất:

 $$\hat{C}_k^{\text{harm}} = \left( \frac{1}{n} \sum_{i=k-n+1}^{k} \frac{1}{C_i} \right)^{-1}$$

Throughput ước lượng $ \hat{C}_k $ được đưa vào rule rate-based/hybrid (C.2.6.1, C.2.6.3) để chọn bitrate.

#### C.2.5.3. Mô hình QoE và bài toán tối ưu

Ta mô tả một session gồm $K$ segment bằng một hàm QoE tổng quát [C16], [C17]:

* $Q_k$: “mức chất lượng” của segment $k$ (có thể là bitrate $R_k$, VMAF, SSIM,…);
* $u(Q_k)$: utility của chất lượng $Q_k$, thường là hàm concave (vd. $u(Q) = \log Q$ hoặc $u(Q) \propto \text{VMAF}$);
* $\alpha$: hệ số phạt switching;
* $\beta$: hệ số phạt stall.

Hàm QoE:

$$\text{QoE} = \sum_{k=1}^{K} u(Q_k) - \alpha \sum_{k=1}^{K-1} \left| Q_{k+1} - Q_k \right| - \beta T_{\text{stall,total}}.$$

Mục tiêu của ABR là thiết kế policy chọn bitrate $R_k$ (hay chất lượng $Q_k$) sao cho:

* QoE kỳ vọng $\mathbb{E}[\text{QoE}]$ được **tối đa**,
* dưới các ràng buộc buffer dynamics và điều kiện mạng (phân bố $C_k$).

Các thuật toán BOLA, MPC, Pensieve đều có thể xem là **xấp xỉ lời giải** của bài toán tối ưu này dưới các giả thiết khác nhau về knowledge, model và khả năng tính toán.

---

### C.2.6. Thuật toán chọn bitrate trong ABR

Các thuật toán ABR có thể phân loại thành ba nhóm lớn [C14], [C16]:

1. **Rate-based (RB)** – dựa trên ước lượng throughput $ \hat{C}_k $.
2. **Buffer-based (BB)** – dựa trên buffer occupancy $ B_k $.
3. **Hybrid** – sử dụng cả throughput và buffer.

Trong nhóm Hybrid, ta xem xét hai thuật toán tiêu biểu: **MPC** (Model Predictive Control) và **Pensieve (Deep RL)**; cùng với một thuật toán buffer-based “có chứng minh” là **BOLA**.

#### C.2.6.1. Thuật toán Rate-Based (RB)

Ý tưởng:

* ước lượng throughput khả dụng $ \hat{C}_k $;
* chọn bitrate $R_k$ sao cho $R_k$ **thấp hơn** một phần của $ \hat{C}_k $ để có margin an toàn.

Một rule đơn giản:

* Cho hệ số safety $0 < \gamma < 1$ (ví dụ $\gamma = 0.8$);
* Tại decision $k$, chọn:

  $$
  R_k = \max \left{
  R^{(m)} \in \mathcal{R}
  \mid
  R^{(m)} \le \gamma \hat{C}_k
  \right}.
  $$

Nếu không tồn tại $R^{(m)}$ thoả $R^{(m)} \le \gamma \hat{C}_k$ thì chọn bitrate thấp nhất $R^{(1)}$.

**Ưu điểm:**

* đơn giản, dễ triển khai;
* phản ứng trực tiếp với thay đổi throughput.

**Nhược điểm:**

* throughput ngắn hạn rất nhiễu (bị jitter, bursty cross-traffic), khiến $R_k$ dao động mạnh;
* không xét đến buffer $B_k$, nên:

  * dù buffer đầy, thuật toán vẫn “lo sợ” mỗi khi throughput sample giảm;
  * buffer trống → không có cơ chế “tự giảm bitrate mạnh” để tránh stall.

Các triển khai thực tế thường thêm **hysteresis**:

* chỉ cho upswitch khi $\hat{C}_k$ đủ cao **và** đã ổn định trong vài segment;
* downswitch khi $\hat{C}_k$ giảm mạnh, giúp giảm oscillation.

#### C.2.6.2. Thuật toán Buffer-Based (BB)

Ý tưởng: **chỉ dùng buffer $B_k$**, không dự đoán băng thông [C17].

Ta chọn một hàm ánh xạ:

$$
f_{\text{BB}} : B_k \mapsto R_k,
$$

thoả:

* khi buffer thấp ($B_k \approx 0$) → chọn bitrate thấp $R^{(1)}$ để tránh stall;
* khi buffer cao ($B_k$ gần dung lượng tối đa $B_{\max}$) → chọn bitrate cao $R^{(M)}$;
* hàm $f_{\text{BB}}$ là **monotonic tăng** theo $B_k$.

Ví dụ mô hình tuyến tính (naive):

* chọn hai ngưỡng:

  * $B_{\min}$: dưới đó luôn chọn bitrate thấp nhất;
  * $B_{\max}$: trên đó luôn chọn bitrate cao nhất.

* với $B_k \in [B_{\min}, B_{\max}]$, ánh xạ tuyến tính sang index bitrate:

$$
\begin{aligned}
x_k &= 1 + (M - 1)\,
\frac{B_k - B_{\min}}{B_{\max} - B_{\min}},
\end{aligned}
$$

  sau đó lấy:

  $$
  m_k = \text{round}(x_k),
  \quad
  R_k = R^{(m_k)}.
  $$

Các thuật toán buffer-based thực tế như **BBA (Buffer-Based Adaptation)** đề xuất mapping tinh vi hơn (piecewise-linear) để ổn định behavior ở vùng buffer thấp và cao [C17].

**Đặc điểm:**

* Khi network tốt, buffer $B_k$ tăng dần → bitrate tăng mượt;
* Khi network xấu, buffer tụt → bitrate tự động giảm mạnh để bảo vệ buffer;
* Không cần ước lượng $\hat{C}_k$ → tránh nhiễu do sample throughput sai.

Netflix và một số hệ thống thực tế đã áp dụng buffer-based (hoặc hybrid thiên buffer) vì tính ổn định cao [C17].

#### C.2.6.3. Thuật toán Hybrid (kết hợp rate + buffer)

Hybrid sử dụng cả:

* thông tin throughput ngắn hạn $ \hat{C}_k $,
* trạng thái “dự trữ” dài hạn $ B_k $.

Một dạng rule đơn giản:

1. Tính bitrate “ứng viên” từ throughput:

   $$
   R_k^{\text{rate}} =
   \max {
   R^{(m)} \le \gamma \hat{C}_k
   }.
   $$

2. Tính bitrate “ứng viên” từ buffer:

   $$
   R_k^{\text{buf}} = f_{\text{BB}}(B_k).
   $$

3. Kết hợp:

   $$
   R_k = \min{ R_k^{\text{rate}}, R_k^{\text{buf}} }
   $$

hoặc một hàm **smoothing** khác (weighted, hysteresis).

Các thuật toán như **ELASTIC**, **DYNAMIC (BOLA-E + throughput)**, **FastMPC** đều thuộc dạng hybrid với biểu thức kết hợp phức tạp hơn, được tối ưu qua mô phỏng thực nghiệm [C16], [C18].

#### C.2.6.4. Thuật toán BOLA (Buffer Occupancy based Lyapunov Algorithm)

BOLA là thuật toán buffer-based nhưng được xây dựng trên cơ sở **tối ưu hóa Lyapunov**, với mục tiêu tối đa hóa utility QoE [C19], [C20]. Ý tưởng:

* Mỗi bitrate $R^{(m)}$ có utility $u_m = u(R^{(m)})$, với $u_m$ concave tăng;
* Hình phạt stall được gộp vào constraint buffer dynamics;
* Sử dụng **Lyapunov drift-plus-penalty** để thiết kế rule chỉ dựa trên buffer $B_k$.

Trong BOLA-BASIC:

* Định nghĩa Lyapunov function về buffer $B_k$: ví dụ $L(B_k) = \frac{1}{2} B_k^2$;
* Đặt tham số điều khiển $V > 0$, điều chỉnh trade-off **chất lượng vs anti-stall**.

BOLA đưa ra rule chọn bitrate index:

$$
m_k = \arg\max_m \Phi_m(B_k)
$$

trong đó $\Phi_m(B_k)$ là hàm mục tiêu **tăng theo utility và buffer** và **giảm theo kích thước segment** $S^{(m)}$; dạng tổng quát:

$$
\Phi_m(B_k)
\propto
\frac{V u_m + g(B_k)}{S^{(m)}},
$$

với $g(B_k)$ là hàm tuyến tính của $B_k$ (chi tiết hệ số và normalizing có trong [C19]). Trực giác:

* Bitrate cao: $u_m$ lớn nhưng $S^{(m)}$ cũng lớn → dễ làm buffer tụt;
* Bitrate thấp: $u_m$ nhỏ nhưng giữ buffer “an toàn”;
* BOLA cân bằng hai yếu tố này dựa trên $V$ và $B_k$:

  * khi $B_k$ thấp → ưu tiên bitrate thấp để tránh stall;
  * khi $B_k$ cao → ưu tiên bitrate cao để tăng utility.

**Điểm mạnh:**

* không cần ước lượng $\hat{C}_k$;
* có **bảo đảm lý thuyết**, utility đạt gần tối ưu trong giới hạn dài hạn với sai số $O(1/V)$ [C19], [C20];
* đã được triển khai trong **dash.js** và sử dụng thực tế bởi nhiều nhà cung cấp (Akamai, BBC, Orange, CBS…) [C20], [C21].

#### C.2.6.5. Thuật toán MPC (Model Predictive Control)

Yin và cộng sự đề xuất một framework **Điều khiển dự đoán mô hình (MPC)** cho ABR [C16]:

* Xem ABR là bài toán điều khiển rời rạc với trạng thái buffer $B_k$;
* Sử dụng **dự báo throughput** cho vài segment phía trước;
* Ở mỗi decision, giải bài toán tối ưu trên một **cửa sổ horizon** $H$ (4–8 segment);

Ký hiệu:

* Horizon $H$;
* vector bitrate chọn trong horizon:
  $$
  \mathbf{q} = (q_k, q_{k+1}, \dots, q_{k+H-1}),
  $$
  trong đó $q_i$ là index bitrate (1…M);
* buffer dự đoán $B_i^{\text{pred}}$ tuân theo buffer dynamics với throughput dự báo $\hat{C}_i$.

Mục tiêu:

$$
\max_{\mathbf{q}}
\left[
\sum_{i=k}^{k+H-1}
u\!\left( R^{(q_i)} \right)
\;-\;
\alpha 
\sum_{i=k}^{k+H-2}
\left| R^{(q_{i+1})} - R^{(q_i)} \right|
\;-\;
\beta\, T_{\text{stall},\text{pred}}
\right]
$$

dưới ràng buộc:

* $B_{i+1}^{\text{pred}}$ được cập nhật từ $B_i^{\text{pred}}$, $R^{(q_i)}$, $\hat{C}_i$;
* $B_i^{\text{pred}} \ge 0$ (hoặc stall được tính vào $T_{\text{stall},\text{pred}}$).

Do $H$ nhỏ và $M$ không quá lớn, có thể giải bằng **enumeration thông minh** hoặc **dynamic programming**. Sau khi tìm được vector $\mathbf{q}^*$, MPC chỉ dùng **phần tử đầu tiên** $q_k^*$ để chọn bitrate hiện tại, rồi lặp lại ở decision tiếp theo với trạng thái cập nhật.

Đặc điểm:

* kết hợp tự nhiên **throughput prediction + buffer**;
* cho phép encode nhiều mục tiêu QoE khác nhau vào hàm utility (startup delay, rebuffering, switching);
* đã chứng minh cải thiện QoE so với RB/BB trên nhiều trace mạng [C16].

#### C.2.6.6. Pensieve – ABR dựa trên Deep Reinforcement Learning

**Pensieve** (Mao et al., SIGCOMM 2017) là hệ thống sử dụng **deep reinforcement learning (DRL)** để *tự học* thuật toán ABR [C22], [C23]:

* Thay vì thiết kế rule bằng tay (RB, BB, MPC), Pensieve học một **policy** $ \pi_\theta $ (mạng neural) ánh xạ trạng thái quan sát $s_k$ → distribution trên bitrate $a_k$.

Ký hiệu:

* Trạng thái $s_k$ gồm:

  * lịch sử throughput $C_{k-1}, C_{k-2}, \dots$ (normalized),
  * lịch sử bitrate đã chọn,
  * buffer hiện tại $B_k$,
  * số segment còn lại,
  * các statistic khác (mức độ stall trong quá khứ,…).

* Hành động $a_k$ là chọn bitrate index $m_k$.

* Reward $r_k$ tại mỗi segment thường được thiết kế theo form QoE:

$$
r_k = u\!\left( R^{(m_k)} \right)
    - \alpha \left| R^{(m_k)} - R^{(m_{k-1})} \right|
    - \beta\, T_{\text{stall},k}.
$$

Pensieve sử dụng:

* Mạng policy $ \pi_\theta(a_k | s_k) $ để sinh hành động;
* Thuật toán policy gradient (vd. REINFORCE, actor–critic) để cập nhật $\theta$ nhằm tối đa hóa:

  $$
  J(\theta)
  = \mathbb{E}*{\pi*\theta} \left[
  \sum_k r_k
  \right].
  $$

Hệ thống được huấn luyện **offline** trên trace mạng và video. Sau khi converge:

* client thực thi policy đã học, với chi phí tính toán tại runtime nhỏ (forward pass mạng).
* Pensieve đã cho thấy vượt trội so với các rule hand-tuned trên nhiều dataset, và có thể thích ứng khi thay đổi metric QoE (thay đổi $u(\cdot)$, $\alpha$, $\beta$) mà không cần thiết kế lại thuật toán [C22], [C23].

---

### Tóm lược mục C.2

Trong mục C.2, ta đã:

* mô hình hóa **kiến trúc ABR trên HTTP** với segment, representation, manifest;
* phân tích chi tiết **MPEG-DASH**, **HLS/LL-HLS**, **CMAF** và vai trò của chúng đối với ABR;
* xây dựng **mô hình toán buffer–throughput–QoE** làm nền cho các thuật toán ABR;
* trình bày các lớp thuật toán:

  * **RB** – đơn giản nhưng nhạy với nhiễu throughput;
  * **BB/BOLA** – ổn định, có cơ sở lý thuyết (Lyapunov);
  * **Hybrid/MPC** – kết hợp throughput và buffer theo cách tối ưu hóa rõ ràng;
  * **Pensieve** – dùng **học tăng cường sâu** để tự động “học” policy ABR tối ưu theo QoE.

Các mô hình và thuật toán này sẽ được sử dụng ở phần D (phân tích kỹ thuật sâu) và E (thiết kế mô phỏng) để đánh giá định lượng trade-off giữa **latency – quality – stability** trong các kịch bản streaming khác nhau.

---

### Tài liệu tham khảo cho mục C.2 (định dạng IEEE)

[C8] ISO/IEC, *Information Technology — Dynamic Adaptive Streaming over HTTP (DASH) — Part 1: Media Presentation Description and Segment Formats*, ISO/IEC 23009-1:2022.

[C9] R. Pantos and W. May, “HTTP Live Streaming,” RFC 8216, IETF, Aug. 2017.

[C10] DASH-IF, *Low-Latency DASH: Implementation Guidelines*, DASH Industry Forum, 2020.

[C11] Apple Inc., “Enabling Low-Latency HTTP Live Streaming (HLS),” Apple Developer Documentation, 2023.

[C12] ISO/IEC, *Information Technology — Multimedia Application Format (MPEG-A) — Part 19: Common Media Application Format (CMAF) for Segmented Media*, ISO/IEC 23000-19:2024.

[C13] Dolby / THEOplayer, “Low Latency with Chunked CMAF,” Dolby OptiView Tech Article, 2018.

[C14] “Adaptive bitrate streaming,” Wikipedia, 2025, accessed Nov. 2025.

[C15] DASH-IF, “Low-Latency Streaming in MPEG-DASH Using CMAF Chunks,” DASH Industry Forum Technical Note, 2019.

[C16] X. Yin, A. Jindal, V. Sekar, and B. Sinopoli, “A control-theoretic approach for dynamic adaptive video streaming over HTTP,” in *Proc. ACM SIGCOMM*, 2015, pp. 325–338.

[C17] T.-Y. Huang *et al.*, “A buffer-based approach to rate adaptation: Evidence from a large video streaming service,” in *Proc. ACM SIGCOMM*, 2014, pp. 187–198.

[C18] S. Akhshabi, A. C. Begen, and C. Dovrolis, “An experimental evaluation of rate-adaptation algorithms in adaptive streaming over HTTP,” in *Proc. ACM MMSys*, 2011, pp. 157–168.

[C19] K. Spiteri, R. Urgaonkar, and R. K. Sitaraman, “BOLA: Near-optimal bitrate adaptation for online videos,” in *Proc. IEEE INFOCOM*, 2016, pp. 1–9.

[C20] K. Spiteri, R. Urgaonkar, and R. K. Sitaraman, “BOLA: Near-optimal bitrate adaptation for online videos,” *IEEE/ACM Trans. Netw.*, vol. 28, no. 4, pp. 1698–1711, Aug. 2020.

[C21] T. Mangla *et al.*, “From theory to practice: Improving bitrate adaptation in the DASH reference player,” in *Proc. ACM MMSys*, 2018, pp. 123–137.

[C22] H. Mao, R. Netravali, and M. Alizadeh, “Neural adaptive video streaming with Pensieve,” in *Proc. ACM SIGCOMM*, 2017, pp. 197–210.

[C23] E. Marx, F. Y. Yan, and K. Winstein, “Implementing BOLA-BASIC on Puffer: Lessons for the use of SSIM in ABR logic,” *CoRR*, arXiv:2011.09611, 2020.

